\documentclass{article}
\usepackage{notes-preamble}
\usepackage{enumitem}
\mkthmstwounified

\title{Introduction to Theoretical Computer Science (SEM6)}
\author{Franz Miltz}
\begin{document}
\maketitle
\noindent Textbook: M. Sipser, \emph{Introduction to the Theory of Computation}
\tableofcontents
\pagebreak

\section{Regular Languages}

\subsection{Finite automata}

\begin{definition}[DFA; Sipser, p. 35]
    A \emph{deterministic finite automaton} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
    \begin{enumerate}
        \item $Q$ is a finite set called the \emph{states},
        \item $\Sigma$ is a finite set called the \emph{alphabet},
        \item $\delta:Q\times\Sigma\to Q$ is the \emph{transition function},
        \item $q_0\in Q$ is the \emph{start state}, and
        \item $F\subseteq Q$ is the \emph{set of accept states}.
    \end{enumerate}
\end{definition}

\begin{definition}
    A \emph{language} $A$ over an alphabet $\Sigma$ is a set such that for all
    $w\in A$ there exist $w_1,w_2,...,w_n\in\Sigma$ such that $w=w_1w_2\cdots w_n$.

    A finite automaton $M=(Q,\Sigma,\delta,q_0,F)$ accepts a word $w=w_1\cdots w_n\in A$
    if there exists a sequence of states $r_0,...,r_n\in Q$ such that
    \begin{enumerate}
        \item $r_0=q_0$,
        \item $\delta(r_i,w_{i+1})=r_{i+1}$, for $i<n$, and
        \item $r_n\in F$.
    \end{enumerate}
    We say $M$ recognises $A$ if and only if $A=\{w : M\text{ accepts }w\}$.
\end{definition}

\begin{definition}[Sipser p. 40]
    A language is called a \emph{regular language} if some finite automaton recognises it.
\end{definition}

\begin{definition}[Sipser p. 44]
    Let $A$ and $B$ be languages. We define the following \emph{regular operations}:
    \begin{enumerate}
        \item \emph{union}: $A\cup B=\{x : x \in A \text{ or } x \in B\}$.
        \item \emph{concatenation}: $A\circ B=\{xy : x \in A \text{ or } y \in B\}$.
        \item \emph{star}: $A^* = \{x_1x_2\dots x_k:k\geq 0 \text{ and each }x_i\in A\}$.
    \end{enumerate}
\end{definition}

\begin{theorem}[Sipser p. 45, 60, 62]
    The class of regular languages is closed under regular operations.
\end{theorem}

\begin{theorem}[Pumping lemma; Sipser p. 78]
    If $A$ is a regular language, then there is a number $p$ where if $s$
    is any string in $A$ of length at least $p$, then $s$ may be divided
    into three pieces, $s=xyz$, satisfying the following conditions:
    \begin{enumerate}
        \item for each $i\geq 0$, $xy^iz\in A$,
        \item $\abs y > 0$, and
        \item $\abs{xy} \leq p$.
    \end{enumerate}
\end{theorem}

\subsection{Nondeterminism}

\begin{definition}[NFA; Sipser p. 53]
    A \emph{nondeterministic finite automaton} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
    \begin{enumerate}
        \item $Q$ is a finite set called the \emph{states},
        \item $\Sigma$ is a finite set called the \emph{alphabet},
        \item $\delta:Q\times\Sigma\to\mathcal{P}(Q)$ is the \emph{transition function},
        \item $q_0\in Q$ is the \emph{start state}, and
        \item $F\subseteq Q$ is the \emph{set of accept states}.
    \end{enumerate}
\end{definition}

\begin{definition}[$\e$-NFA; Sipser p. 53]
    An \emph{$\e$-NFA} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
    \begin{enumerate}
        \item $Q$ is a finite set called the \emph{states},
        \item $\Sigma$ is a finite set called the \emph{alphabet},
        \item $\delta:Q\times\Sigma_\e\to \mathcal{P}(Q)$ is the \emph{transition function},
        \item $q_0\in Q$ is the \emph{start state}, and
        \item $F\subseteq Q$ is the \emph{set of accept states}.
    \end{enumerate}
\end{definition}

\begin{theorem}[Sipser p. 55]
    Let $L$ be a language. Then the following statements are equivalent:
    \begin{enumerate}
        \item $L$ is regular.
        \item There exists a DFA $M$ that recognises $L$.
        \item There exists an NFA $M$ that recognises $L$.
        \item There exists an $\e$-NFA $M$ that recognises $L$.
    \end{enumerate}
\end{theorem}

\subsection{Regular expressions}

\begin{definition}[Sipser p. 64]
    $R$ is a \emph{regular expression} over an alphabet $\Sigma$ if one of the following holds:
    \begin{enumerate}
        \item $R\in\Sigma$,
        \item $R=\e$,
        \item $R=\emptyset$,
        \item $R=(R_1\cup R_2)$, where $R_1,R_2$ are regular expressions,
        \item $R=(R_1\circ R_2)$, where $R_1,R_2$ are regular expressions, or
        \item $R=(R_1^*)$, where $R_1$ is a regular expression.
    \end{enumerate}
\end{definition}

\begin{theorem}[Sipser p. 66]
    A language is regular if and only if some regular expression describes it.
\end{theorem}

\begin{definition}[GNFA; Sipser p. 53]
    A \emph{generalised NFA} is a $5$-tuple $(Q,\Sigma,\delta,q_0,q_1)$ where
    \begin{enumerate}
        \item $Q$ is a finite set called the \emph{states},
        \item $\Sigma$ is a finite set called the \emph{alphabet},
        \item $\delta:(Q\setminus\{q_0\})\times(Q\setminus\{q_1\})\to R$ is the \emph{transition function},
        \item $q_0\in Q$ is the \emph{start state}, and
        \item $q_1\in Q$ is the \emph{accept state},
    \end{enumerate}
    where $R$ is the collection of all regular expressions over the alphabet $\Sigma$.
\end{definition}

\section{Context-free languages}

\subsection{Context-free grammars}

\begin{definition}[Sipser p. 104]
    A \emph{context-free grammar} (CFG) is a 4-tuple $(V,\Sigma,R,S)$ where
    \begin{enumerate}
        \item $V$ is a finite set called the \emph{variables},
        \item $\Sigma$ is a finite set called the \emph{terminals},
        \item $R\subseteq V\times(V\cup\Sigma)^*$ is a finite set of \emph{rules},
        \item $S\in V$ is the \emph{start variable}.
    \end{enumerate}
\end{definition}

\begin{definition}
    Let $G=(V,\Sigma,R,S)$ be a CFG and let $u,v\in(V\cup\Sigma)^*$.
    We say \emph{$u$ derives $v$}, written $u\Rightarrow^* v$, if $u=v$ or if a sequence
    $u_1,...,u_k$ exists for $k\geq 0$ such that
    \begin{align*}
        u\Rightarrow u_1 \Rightarrow ... \Rightarrow u_k \Rightarrow v.
    \end{align*}
    The \emph{language of the grammar} $G$ is $L=\{w\in\Sigma^*:S\Rightarrow^* w\}$,
    called a \emph{context-free language} (CFL).
\end{definition}

\begin{definition}[Sipser p. 108]
    A string $w$ is derived \emph{ambiguously} in CFG $G$ if it has
    two or more different leftmost derivations. Grammar $G$ is \emph{ambiguous} if it
    generates some string ambiguously.
    A language which is only generated by ambiguous grammars is called \emph{inherently
        ambiguous}.
\end{definition}

\begin{definition}[Sipser p. 109]
    A CFG $G=(V,\Sigma,R,S)$ is in \emph{Chomsky normal form} if every rule is of the
    form
    \begin{align*}
        A\to BC, \hs
        A\to a, \hs
        S\to\e
    \end{align*}
    where $a\in\Sigma$ and $B,C\in V$
\end{definition}

\begin{theorem}[Sipser p. 109]
    Any CFL is generated by a CFG in Chomsky normal form.
\end{theorem}

\subsection{Pushdown automata}

\begin{definition}[Sipser p. 113]
    A \emph{pushdown automaton} (PDA) is a 6-tuple $(Q,\Sigma,\Gamma,\delta,q_0,F)$,
    where
    \begin{enumerate}
        \item $Q$ is the finite set of states,
        \item $\Sigma$ is the finite input alphabet,
        \item $\Gamma$ is a finite set called the \emph{stack alphabet},
        \item $\delta:Q\times \Sigma_\e\times\Gamma_\e\to\mathcal{P}(Q\times\Gamma_\e)$ is the transition function,
        \item $q_0\in Q$ is the start state, and
        \item $F\subseteq Q$ is the set of accept states.
    \end{enumerate}
    Let $M=(Q,\Sigma,\Gamma,\delta,q_0,F)$ and $w=w_1\cdots w_m$, where
    $w_1,...,w_m\in\Sigma_\e$. Then $M$ accepts $w$ if there exists a sequence of
    states $r_0,...,r_m\in Q$ and strings $s_0,...,s_m\in\Gamma^*$ such that
    \begin{enumerate}
        \item $r_0=q_0$ and $s_0=\e$,
        \item for $i<m$, we have $(r_{i+1},b)\in\delta(r_i,w_{i+1},a)$, where $s_i=at$
              and $s_{i+1}=bt$ for some $a,b\in\Gamma_\e$ and $t\in\Gamma^*$,
        \item $r_m\in F$.
    \end{enumerate}
\end{definition}

\begin{theorem}[Sipser p. 117]
    A language is context-free if and only if a pushdown automaton recognises it.
\end{theorem}

\begin{corollary}[Sipser p. 124]
    Every regular language is context-free.
\end{corollary}

\subsection{Non-context-free languages}

\begin{theorem}[Pumping lemma for context-free languages; Sipser p. 125]
    If $A$ is a context-free language, then there is a number $p$ where,
    if $s$ is any string in $A$ of length at least $p$, then $s$ may be
    divided into five pieces $s=uvxyz$ such that
    \begin{enumerate}
        \item for each $i\geq 0$ $uv^ixy^iz\in A$,
        \item $\abs{vy}>0$, and
        \item $\abs{vxy}\leq p$.
    \end{enumerate}
\end{theorem}

\subsection{Deterministic context-free languages}

Let $G=(V,\Sigma,R,S)$ be a CFG.

\begin{definition}[Sipser p. 130]
    A \emph{deterministic PDA} is a 6-tuple $(Q,\Sigma,\Gamma,\delta,q_0,F)$,
    where
    \begin{enumerate}
        \item $Q$ is the finite set of states,
        \item $\Sigma$ is the finite input alphabet,
        \item $\Gamma$ is the finite stack alphabet,
        \item $\delta:Q\times\Sigma_\e\times\Gamma_\e\to(Q\times\Gamma_\e)\cup\{\emptyset\}$ is the transition function
        \item $q_0\in Q$ is the start state, and
        \item $F\subseteq Q$ is the set of accept states.
    \end{enumerate}
    The transition function $\delta$ must satisfy the following condition. For every
    $q\in Q$, $a\in\Sigma$, and $x\in\Gamma$, exactly one of the values
    \begin{align*}
        \delta(q,a,x),\hs \delta(q,a,\e),\hs \delta(q,\e,x),\hs \delta(q,\e,\e)
    \end{align*}
    is not $\emptyset$. The language accepted by a DPDA is called a \emph{deterministic
        context-free language} (DCFL).
\end{definition}

\begin{lemma}[Sipser p. 132]
    Every DPDA has an equivalent DPDA that always reads the entire input string.
\end{lemma}

\begin{theorem}[Sipser p. 133]
    The class of DCFLs is closed under complementation.
\end{theorem}

\begin{definition}[Sipser p. 134]
    Let $A$ be a language. Then the \emph{endmarked language} $A\!\dashv$ is given by
    \begin{align*}
        A\!\dashv\: = \{w\!\dashv\:: w \in A\}.
    \end{align*}
\end{definition}

\begin{theorem}[Sipser p. 134]
    Let $A$ be a language. Then $A$ is a DCFL if and only if $A\!\dashv$ is a DCFL.
\end{theorem}

\begin{definition}[Sipser p. 136]
    Let $u,v\in(V\cup\Sigma)^*$. We say $u$
    \emph{reduces} $v$, written $u\Leftarrow^*v$ if there exists a sequence
    $u_1,...,u_k$ for $k\geq 0$ such that
    \begin{align*}
        u = u_1 \Leftarrow ... \Leftarrow u_k \Leftarrow v.
    \end{align*}
    The sequence $u_1,...,u_k$ is called a \emph{reduction from u to v}. A \emph{reduction from $u$}
    is a reduction from $u$ to $S$.
\end{definition}

\begin{definition}[Sipser p. 136]
    In a \emph{leftmost reduction}, each reducing string is reduced only after all
    other reducing strings that lie entirely to its left.

    Let $w\in L(G)$ and let $u_1,...,u_k$ be a leftmost reduction of $w$.
    Let $T\to h$ be a rule in $R$ such that $u_i=xhy$ and $u_{i+1}=xTy$ for some $x,y$ and some
    $i<k$. Then $h$ together with the rule $T\to h$ is called a \emph{handle} of $u_i$.
\end{definition}

\begin{definition}[Sipser p. 136]
    A string $u\in(V\cup\Sigma)^*$ is called \emph{valid} if
    there exists a word $w\in L(G)$ and a leftmost reduction $u_1,...,u_k$ such that $u=u_i$ for
    some $i\leq k$.
\end{definition}

\begin{lemma}[Sipser p. 137]
    In an unambiguous CFG, any valid string has precisely one handle.
\end{lemma}

\begin{definition}[Forced handles; Sipser p. 138]
    A handle $h$ of a valid string $v=xhy$ with respect to $G$ is \emph{forced} if $h$ is
    the unique handle in every valid string $xh\hat y$ where $\hat y\in\Sigma^*$.
\end{definition}

\begin{definition}[DCFG; Sipser p. 139]
    A \emph{deterministic CFG} (DCFG) is a CFG such that every valid string has a forced handle.
\end{definition}

\begin{lemma}[Sipser p. 140]
    \label{klemma}
    Let $G=(V,\Sigma,R,S)$ be a DCFG and let $K$ be an NFA such that the states correspond to
    dotted rules in $G$, i.e. for every rule $B\to u_1\cdots u_k$ with $u_1,...,u_k\in V\cup\Sigma$
    there are $k+1$ dotted rules
    \begin{align*}
        B & \to .u_1u_2\cdots u_k \\
        B & \to u_1.u_2\cdots u_k \\
        B & \to u_1u_2.\cdots u_k \\
          & \hs\vdots             \\
        B & \to u_1u_2\cdots .u_k \\
        B & \to u_1u_2\cdots u_k,
    \end{align*}
    the transitions correspond to shift-moves, where for some rule $B\to uav$ we transition from
    $B\to u.av$ to $B\to ua.v$ upon reading $a$, and $\e$-moves, where for some rules
    $B\to uCv$ and $C\to r$ we $\e$-transition from $B\to u.Cv$ to $C\to r.$ and the accept states
    are all $B\to u.$.

    Then $K$ may enter state $T\to u.v$ on reading input $z$ if and only if $z=xu$ and
    $xuvy$ is a valid string with handle $uv$ and reducing rule $T\to uv$, for some $y\in\Sigma^*$.
    Further, $K$ may enter accept state $T\to h.$ on input $z$ if and only if $z=xh$ and $h$ is a
    handle of some valid string $xhy$ with reducing rule $T\to h$.
\end{lemma}

\begin{theorem}[DK-test; Sipser p. 143]
    Let $DK$ be the DFA corresponding to the NFA $K$ from (\ref{klemma}). Then $G$ is a
    DCFG if and only if every one of $DK$'s accept states contains
    \begin{enumerate}
        \item exactly one completed rule, and
        \item no dotted rule of the form $B\to u.av$ for $a\in\Sigma$.
    \end{enumerate}
\end{theorem}

\begin{theorem}
    An endmarked language is generated by a DCFG if and only if it is deterministic context-free.
\end{theorem}

\begin{definition}[LR(k) grammar; Sipser p. 152]
    A handle $h$ of a valid string $v=xhy$ with respect to CFG $G$ is \emph{forced by lookahead k}
    if $h$ is the unique handle in every valid string $xh\hat y$ where $\hat y\in\Sigma^*$ and
    $y$ and $\hat y$ do not differ in their first $k$ symbols.

    An $LR(k)$ grammar is a CFG grammar such that the handle of every valid string is forced by
    lookahead $k$.
\end{definition}

\begin{theorem}[Sipser p. 154]
    An endmarked language is generated by an $LR(1)$ grammar if and only if it is a DCFL.
\end{theorem}

\section{Register machines and Turing machines}

\subsection{Programs}

\begin{definition}[Notes I.1]
    A \emph{register machine} (RM) has a fixed number of registers $R_0,...,R_{m-1}$
    which each hold a natural number and a fixed program, i.e. a sequence of
    instructions $P=I_0,...,I_{n-1}$. Each instruction is one of
    \begin{enumerate}
        \item $\inc(i)$, to add $1$ to $R_i$, or
        \item $\decjz(i,j)$, if $R_i=0$ then go to $I_j$, else substract $1$ from $R_i$.
    \end{enumerate}
    Instructions are exectued instructions in order, except when
    a jump is triggered.
\end{definition}

\begin{definition}[Notes I.2]
    A \emph{state} of a register machien $M$ as above is a tuple $(R_0,...,R_{m-1},C)$
    where $R_i\in\N$ is the value of register $i$, and $0\leq C\leq n$ is the
    \emph{program counter}.

    The next state function is a partial function from states to states, defined
    as follows: if $s=(R_0,...,R_{m-1},C)$ is a state then $\text{next}(s)$ is undefined
    if $C=n$ and otherwise is $s'=(R'_0,...,R'_{m-1},C')$ where
    \begin{itemize}
        \item if $I_C = \inc(i)$ then $C'=C+1$ and $R'_i = R_i + 1$ and $R'_k=R_k$ for $k\not=i$;
        \item if $I_C=\decjz(i,j)$ and $R_i>0$ then $C'=C+1$ and $R'_i=R_i-1$ and $R'_k = k$ for $k\not = i$;
        \item if $I_C=\decjz(i,j)$ and $R_i=0$ then $C'=j$ and $R'_k=R_k$ for all $k$.
    \end{itemize}
    We write $s\to s'$ if $s'=\text{next}(s)$.

    An \emph{input} for $M$ is a tuple $R=(R_0,...,R_{m-1})$ of values for the registers.
    A \emph{run} of $M$ on input $R$ is a sequence of states $(R_0,...,R_{m-1},0)=s_0\to s_1\to\dots$
    such that either the sequence is infinite or the sequence is finite and the final
    state $s_f$ has no next state. The \emph{output} of $M$ on input $R$ is the tuple
    $R'$ of register values in state $s_f$, or undefined if there is no final state.
\end{definition}

\begin{definition}[Notes I.3]
    An \emph{extended register machine program} comprises
    \begin{itemize}
        \item A set $L$ of labels,
        \item a sequence $I_0,...,I_{n-1}$ of extended instructions,
        \item a labelling function $\text{lab}:L\to\{0,..,n\}$, and
        \item a list $D_0,...,D_l$ of macro definitions.
    \end{itemize}
    An extended instruction is
    \begin{itemize}
        \item $\inc(i)$ or $\decjz(i,j)$ where $i$ is either an integer or a macro
              register parameter and $j$ is a non-negative integer, or a label, or
              a macro label paramerter, or
        \item a macro invocation, which has the form $\text{NAME}(i_1,...,i_r,j_1,...,j_s)$,
              where NAME is defined in the macro definition list, $i_1,...,i_r$ and $j_1,...j_s$
              are as for $i$ and $j$ above, and $r$ and $s$ match the number of parameters
              in the definition.
    \end{itemize}
    In either case, a macro parameter can only occur in the body of a macro definition
    and must be one of the parameters of the definition.

    A macro definition has the form $\text{NAME}(\rho_1,...,\rho_r,\lambda_1,...,\lambda_s)=H_0\cdots H_t$
    where the $\rho_i$ are the $r$ register parameters, the $\lambda_i$ are the $s$
    label parameters and the $H_k$ are extended instructions forming the body of the
    definition.
\end{definition}

\subsection{Pairing and encoding functions}

\begin{definition}[Notes I.5]
    A \emph{pairing function} is an injective function $\lra{-,-}_2:\N\times\N\to\N$.
    If $z=\lra{x,y}_2$ then we may write $z_0:=x$ and $z_1:=y$.
\end{definition}

\begin{theorem}
    Let $M$ be a general RM. Then there exists a 2-register RM $M'$ such that
    $M'$ computes a suitable encoding of $M$.
\end{theorem}

\begin{definition}
    Let $M$ be a register machine and let $R$ be the register contents $R_0,...,R_{m-1}$,
    $P=I_0,...,I_{n-1}$ be the program itself and let $C$ be the program counter.
    Let $\lra{-,-}$ be a sequence encoding function.

    We define the RM coding function $[-]$ by:
    \begin{align*}
        [\inc(i)]     & = \lra{0,i}                   \\
        [\decjz(i,j)] & = \lra{1,\lra{i,j}}           \\
        [P]           & = \lra{[I_0], ..., [I_{n-1}]} \\
        [R]           & = \lra{R_0, ..., R_{m-1}}     \\
        [M]           & = \lra{[P], [R], C}
    \end{align*}
\end{definition}

\begin{theorem}[Notes I.7]
    There is a register machine $U$ which takes as input the code $\left[M\right]$ of the
    initial state of an arbitrary RM $M$ and gives as output the code of the final
    state, if there is one. If $M$ does not halt, $U$ does not halt on input
    $\left[M\right]$.
\end{theorem}

\subsection{Turing machines}

\begin{definition}[Turing machine; Sipser p. 168]
    A \emph{Turing machine} is a 7-tuple, $(Q, \Sigma, \Gamma, \delta, q_0, q_a, q_r)$,
    where $Q,\Sigma,\Gamma$ are all finite sets and
    \begin{enumerate}
        \item $Q$ is the set of states,
        \item $\Sigma$ is the input alphabet not containing the \emph{blank symbol $\sqcup$},
        \item $\Gamma$ is the tape alphabet, where $\sqcup\in\Gamma$ and $\Sigma\subset\Gamma$,
        \item $\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R\}$ is the transition function,
        \item $q_0\in Q$ is the start state,
        \item $q_a\in Q$ is the accept state,
        \item $q_r\in Q$ is the reject state.
    \end{enumerate}
\end{definition}

\begin{definition}[Sipser p. 170]
    A language is called \emph{Turing-recognisable} or \emph{recursively enumerable}
    if some Turing machine recognises it.
\end{definition}

\begin{definition}[Sipser p. 170]
    A \emph{decider} is a Turing machine that always halts. A language is called
    \emph{Turing-decidable} or \emph{recursive} if some Turing machine decides it.
\end{definition}

\subsection{Variants of Turing machines}

\begin{theorem}[Sipser p. 176-180]
    Let $L$ be a language. Then the following are equivalent:
    \begin{enumerate}
        \item $L$ is Turing-recognisable.
        \item Some multitape Turing machine recognises it.
        \item Some nondeterministic Turing machine recognises it.
    \end{enumerate}
\end{theorem}

\begin{corollary}[Sipser p. 180]
    A language is decidable if and only if some nondeterministic Turing machine
    decides it.
\end{corollary}

\section{Computability}

\subsection{Generalised computability}

\begin{definition}
    A (total) function $f:\N\to\N$ is \emph{computable} if there is an RM/TM which 
    computes $f$ and always terminates.
\end{definition}

\begin{theorem}
    There exists a function $f:\N\to\N$ which is not computable.
    \begin{proof}
        Note we can encode RMs as natural numbers, thus the set of all RMs is countable.
        By diagonalisation, we may show that the set of all functions $f:\N\to\N$ is 
        uncountable. Thus there are more functions than RMs.
    \end{proof}
\end{theorem}

\begin{theorem}[Notes I.8]
    There is no Register Machine $H$ such that $H$ takes as input an RM state encoding
    $[M]$ and halts with output $1$ if $M$ halts or output $0$ if $M$ does not halt. 
\end{theorem}


\begin{definition}
    A \emph{decision problem} is a set $D$ and a subset $Q\subseteq D$.
    The problem is \emph{computable} iff the predicate $Q$ is computable. 
\end{definition}

\subsection{Reductions}

\begin{definition}
    Given a decision problem $(D,Q)$, an \emph{oracle} for $Q$ is an additional 
    RM instruction $\text{ORACLE}_Q(i)$ which assumes that $R_i$ contains an
    encoding of some $d\in D$, and sets $R_i$ to contain $Q(d)$.
\end{definition}

\begin{definition}
    A \emph{Turing transducer} is an RM that takes an instance $d$ of a problem $(D,Q)$
    in $R_0$ and halts with instance $d'=f(d)$ of $(D',Q')$ in $R_0$.
\end{definition}

\begin{definition}
    A \emph{mapping reduction} or \emph{many-one reduction} from $Q$ to $Q'$ is a
    Turing transducer $f$ such that $d\in Q$ iff $f(d)\in Q'$. We write $Q\leq_m Q'$
    iff there is an $m$-reduction from $Q$ to $Q'$.
\end{definition}

\begin{definition}
    A \emph{Turing reduction} from $(D,Q)$ to $(D',Q')$ is an RM $M$, equipped with
    an oracle for $Q'$ such that $M$ computes $Q$.
\end{definition}

\begin{theorem}[Notes I.15]
    Let $(D,Q)$ be a problem. Suppose there is an $m$-reduction $R(H,Q)$ from 
    $(RM, H)$ to $(D,Q)$. Then $Q$ is undecidable. 
\end{theorem}

\subsection{Semi- and co-semi-decidability}

\begin{definition}
    The \emph{Looping Problem} $L$ is the subset of Register Machines with specified
    inputs which do not terminate.
\end{definition}

\begin{theorem}
    $L$ is undecidable.
\end{theorem}

\begin{definition}
    A problem $(D,Q)$ is \emph{semi-decidable} iff there exists a RM $M$ taking 
    input $d\in D$ such that if $d\in Q$ then $M$ halts with output $1$ and if
    $d\not\in Q$ then $M$ either halts with output $0$ or not at all.
\end{definition}

\begin{corollary}
    The halting problem $H$ is semi-decidable.
\end{corollary}

\begin{definition}
    A problem $(D,Q)$ is \emph{co-semi-decidable} iff there exists an RM $M$
    taking input $d\in D$ such that if $d\not\in Q$ then $M$ halts with output
    $0$ and if $d\in Q$ then $M$ either halts with output $1$ or doe snot halt.
\end{definition}

\begin{theorem}
    $(D,Q)$ is semi-decidable iff $(D, Q^C)$ is co-semi-decidable.
\end{theorem}

\subsection{Enumerability and the interleaving technique}

\begin{definition}
    An enumeration of a set $S$ is a surjective function $f:\N\to S$. A set $S$ 
    is said to be \emph{enumerable} if there exists an enumeration of $S$.
\end{definition}

\begin{definition}
    Let $Q\subseteq\N$. The set $Q$ is \emph{computably enumerable} iff there is
    an enumeration $f:\N\to Q$ of $Q$ such that $f$ is computable.
\end{definition}

\begin{theorem}
    Let $Q\subseteq\N$. Then the following are equivalent
    \begin{enumerate}
        \item $Q$ is computably enumerable.
        \item There is an RM $M$ which on input $i$ always halts and outputs some $q_i\in Q$,
            and moreover $Q=\{q_i : i\geq 0\}$.
        \item There is an RM $M$ which on input $i$ outputs a coded sequence $\lra{q_0,...,q_i}$,
            and $Q=\{q_i:i\geq 0\}$.
    \end{enumerate}
\end{theorem}

\begin{theorem}[Notes I.25]
    If $Q$ is decidable then $Q$ is computably enumerable.
\end{theorem}

\begin{theorem}[Notes I.26, I.27]
    $Q$ is semi-decidable iff $Q$ is computably enumerable.
\end{theorem}

\subsection{The uniform halting problem}

\begin{definition}
    The \emph{Uniform Halting Problem} (UH) is the subset of Register Machines
    which halts on every input.
\end{definition}

\begin{theorem}[Notes I.28]
    If $(D,Q)$ is both semi-decidable and co-semi-decidable then it is decidable.
\end{theorem}

\begin{corollary}
    $H$ is not co-semi-decidable and $L$ is not semi-decidable.
\end{corollary}

\begin{corollary}
    If there is an $m$-reduction from $H$ to $Q$ then $Q$ is not co-semi-decidable.
\end{corollary}

\begin{theorem}[Notes I.31]
    UH is not semi-decidable. 
\end{theorem}

\subsection{$Q$-decidability}

\begin{definition}
    Let $Q$ be a problem. We say that $Q'$ is $Q$-semi-decidable if it is semi-decidable
    by a machine equipped with an oracle for $Q$. Let $\Sigma^T(Q)$ be the class of
    $Q$-semi-decidable problems. Similarly, let $\Pi^T(Q)$ and $\Delta^T(Q)$ be the 
    classes of $Q$-co-semidecidable and $Q$-decidable problems.
\end{definition}

\begin{theorem}
    $UH\in\Pi^T(H)$.
\end{theorem}

\begin{definition}
    Let $\Sigma_0^T=\Pi^T_0=\Delta^T_0$ be the class of decidable problems. We say 
    that $Q$ is $\Sigma_{n+1}^T$ (respectively $\Pi_{n+1}^T$, $\Delta_{n+1}^T$)
    if there is some problem $Q'\in\Sigma_n^T$ such that $Q\in\Sigma^T(Q')$
    (respectively $\Pi^T(Q')$, $\Delta^T(Q')$).
\end{definition}

\begin{definition}
    Let $Q$ be a problem. There is no register machine $H_Q$ with an oracle $Q$ 
    such that $H_Q$ takes as input an RM-with-oracle-for-$Q$ state encoding 
    $[M]$ and halts with output $1$ if $M$ halts or output $0$ if $M$ does not halt.
\end{definition}

\begin{theorem}
    If $Q\in\Sigma_n^T\cap\Pi_n^T$ then $Q\in\Delta^T_n$.
\end{theorem}

\subsection{Computability and logic}

\begin{definition}
    A set $S\subseteq\N$ is defined by a formula $\phi(x)$ with one free variable
    $x$ iff $S=\{x:\phi(x)\}$ and similarly for sets of tupes of numbers.
\end{definition}

\begin{definition}
    A formula is $\Sigma_0^0$ and $\Pi_0^0$ iff it has no quantifiers, i.e. is 
    constructred from basic formulae and terms using only boolean connectives.

    A formula is $\Sigma_{n+1}^0$ (respectively $\Pi_{n+1}^0$) iff it has the form 
    $\exists x_1,...,x_k.\phi$ (respectively $\forall x_1,...,x_k.\phi$) where
    $\phi$ is a $\Pi_n^0$ (respectively $\Sigma_n^0$) formula.
\end{definition}

\begin{definition}
    A set $S\subseteq\N$ is in the class $\Sigma_n^0$ (respectively $\Pi_n^0$)
    iff it can be defined by a $\Sigma_n^0$ (respectively $\Pi_n^0$)
    formula. The class $\Delta_n^0 = \Sigma_n^0\cap\Pi_n^0$.
\end{definition}

\begin{theorem}[Notes I.40]
    $\Sigma_n^T=\Sigma_n^0$ (and so $\Pi_n^T=\Pi_n^0$). 
\end{theorem}

\begin{theorem}
    The language of first-order arithmetic is first-order logic with symbols for 
    equality, addition and multiplication over $\N$. Any semi-decidable predicate on
    $\N$ can be defined by a $\Sigma_0^1$ formula of this logic.
\end{theorem}

\subsection{Primitive and partial recursion}

\begin{definition}
    A function $f:\N^n\to\N$ is \emph{primitive recursive} if
    \begin{enumerate}[label=R\arabic*.]
        \item $f=0$, or
        \item $f$ is the successor function, i.e. $f(n)=S(n)=n+1$, or 
        \item $f$ is a projection function, i.e. for some $i$, $f((x_1,...,x_n))=x_i$, or 
        \item $f$ is a composition of a $k$-ary function $h$ with $k$ $n$-ary functions $g_1,...,g_k$, i.e.
            $f(x_1,...,x_m)=h(g_1(x_1,...,x_m),...,g_k(x_1,...,x_m))$ where $h,g_1,...,g_k$ are p.r., or 
        \item $f$ is given by the \emph{schema of primitive recursion} for some $n-1$-ary function $h$ and 
            $n+1$-ary function $h$, i.e. 
            \begin{align*}
                f(0,x_1,...,x_k)    &= h(x_1,...,x_k)\\
                f(S(y),x_1,...,x_k) &= g(y,f(y,x_1,...,x_k),x_1,...,x_k)
            \end{align*}
    \end{enumerate}
\end{definition}

\begin{theorem}[Notes I.43]
    The \emph{Ackermann function} $A:\N^2\to\N$ defined by 
    \begin{align*}
        A(0,n) &= S(n) \\
        A(S(m), 0) &= A(m,S(0)) \\
        A(S(m), S(n)) &= A(m, A(S(m), n))
    \end{align*}
    is not a primitive recursive function.
\end{theorem}

\begin{definition}
    A function $f:\N^n\to\N$ is \emph{partial recursive} if it is primitive recursive or 
    \begin{enumerate}[label=R\arabic*.]
        \setcounter{enumi}{5}
        \item for some $(k+1)$-ary total partial recursive function $g$ it is the function $\mu(g)$
            which returns the least $y$ such that $f(y,x_1,...,x_k)=0$ or is undefined if no such $y$
            exists.
    \end{enumerate}
\end{definition}

\begin{theorem}[Notes I.45]
    The computable functions are exactly the total recursive functions. The computable partial functions 
    are exactly the partial recursive functions. 
\end{theorem}

\end{document}