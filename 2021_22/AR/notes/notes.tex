\documentclass{article}
\usepackage{notes-preamble}
\usepackage{enumitem}
\mkthms

\title{Automated Reasoning (SEM5)}
\author{Franz Miltz}
\begin{document}
\maketitle
\tableofcontents
\pagebreak
\section{Introduction}
\begin{definition}
    \emph{Automated Reasoning} refers to reasoning in a computer using logic.
    \begin{itemize}
        \item active area of research since the 50s
        \item part of artificial intelligence
    \end{itemize}
\end{definition}
\begin{theorem}
    Formalised mathematics is neither
    \begin{itemize}
        \item \emph{complete} (see G\"odel's Incompleteness Theorems), nor
        \item \emph{decidable} (see Church and Turing).
    \end{itemize}
\end{theorem}

\section{Propositional Logic}

\begin{definition}
    A syntactically correct formula is called a \emph{well-formed formula}.

    Given an alphabet of propositional symbols $\mathcal{L}$, the
    set of wffs is the smallest set such that 
    \begin{itemize}
        \item any symbol $A\in\mathcal{L}$ is a wff;
        \item if $P$ and $Q$ are wffs, so are $\neg P, P\vee Q, P\wedge Q, P\rightarrow Q$, and $P\leftrightarrow Q$;
        \item if $P$ is a wff, then $(P)$ is a wff.
    \end{itemize}
\end{definition}

\begin{definition}
    An \emph{interpretation} (or \emph{valuation}) $V$ is a truth assignment
    to the symbols in the alphabet $\mathcal{L}$, i.e. a function
    \begin{align*}
        V:\mathcal{L}\to \{\top,\bot\}.
    \end{align*}
\end{definition}

\begin{definition}
    An interpretation $V$ \emph{satisfies} a wff $P$ if $[\![ P]\!]_V=\top$.
\end{definition}

\begin{definition}
    A wff is \emph{satisfiable} if there exists an interpretation that satisfies it.
    Otherwise it's unsatisfiable.
\end{definition}

\begin{definition}
    A wff is \emph{valid} if every interpretation satisfies it.
\end{definition}

\begin{definition}
    The wffs $P_1, P_2,...,P_n$ \emph{entail} $Q$ if any interpretation
    which satisfies all of $P_1, P_2,...,P_n$ also satisfies $A$.
    We write 
    \begin{align*}
        P_1, P_2, ..., P_n \vDash Q.
    \end{align*}
\end{definition}

\subsection{Natural deduction}


\begin{definition}
    \emph{Natural deduction} uses the following rules:
    \begin{align*}
        \begin{array}{c c c}
            \infer[(\text{conjI})]{P\wedge Q}{P\hs Q} &
            \infer[(\text{conjunct1})]{P}{P\wedge Q} &
            \infer[(\text{conjunct2})]{Q}{P\wedge Q} \\
            \infer[(\text{disjI1})]{P\vee Q}{P} &
            \infer[(\text{disjI2})]{P\vee Q}{Q} &
            \infer[(\text{disjE})]{R}{P\vee Q \hs \begin{array}[b]{c}
                [P]\\ \vdots \\ R
            \end{array}
            \hs \begin{array}[b]{c}
                [Q]\\ \vdots \\ R
            \end{array}}\\
            \infer[(\text{impI})]{P\to Q}{\begin{array}[b]{c}
                [P]\\\vdots\\Q 
            \end{array}} &
            \infer[(\text{impE})]{R}{P\to Q\hs P \hs \begin{array}[b]{c}
                [Q]\\\vdots\\R
            \end{array}}&
            \infer[(\text{mp})]{Q}{P\to Q\hs P}\\
            \infer[(\text{iffI})]{P\leftrightarrow Q}{\begin{array}[b]{c}
                [Q]\\\vdots\\P
            \end{array}\hs\begin{array}[b]{c}
                [P]\\\vdots\\Q
            \end{array}} &
            \infer[(\text{iffD1})]{Q}{P\leftrightarrow Q\hs P}&
            \infer[(\text{iffD2})]{P}{P\leftrightarrow Q\hs Q}\\
            \infer[(\text{notI})]{\neg P}{\begin{array}[b]{c}
                P \\ \vdots \\ \bot
            \end{array}} &
            \infer[(\text{notE})]{\bot}{P\hs\neg P} & \\
            \infer[(\text{excluded\_middle})]{\neg P \vee P}{} &
            \infer[\text{(ccontr)}]{P}{\begin{array}[b]{c}
                [\neg P] \\ \vdots \\ \bot
            \end{array}}
        \end{array}
    \end{align*}
\end{definition}

\begin{theorem}[Soundness]
    If $Q$ is provable from assumptions $P_1,...,P_2$ then $P_1,...,P_n\vDash Q$. 
\end{theorem}
\begin{theorem}[Completeness]
    If $P_1,...,P_n\vDash Q$ then $Q$ is provable from assumptions $P_1,...,P_2$. 
\end{theorem}

\subsection{Propositional Reasoning in Isabelle}

\newcommand{\db}[1]{[\![#1]\!]}

\begin{definition}
    Applying \texttt{rule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $Q$ and $C$ can be \emph{unified}, we generate the goals
    \begin{align*}
        \db{A'_1; ...; A'_n} &\Rightarrow P'_1\\
        &\vdots \\
        \db{A'_1; ...; A'_n} &\Rightarrow P'_m
    \end{align*}
    where \begin{align*}
        A'_1, ..., A'_n,P'_1,...,P'_m
    \end{align*}
    are the results of applying the
    substitution which unfies $Q$ and $C$ to
    \begin{align*}
        A_1,...,A_n,P_1,...,P_m.
    \end{align*}
\end{definition}

\begin{definition}
    Applying \texttt{erule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $Q$ and $C$ are unifiable and $P_1$ and $A_1$ are unifiable, we generate the goals
    \begin{align*}
        \db{A'_2; ...; A'_n} &\Rightarrow P'_2\\
        &\vdots \\
        \db{A'_2; ...; A'_n} &\Rightarrow P'_m
    \end{align*}
    where \begin{align*}
        A'_2, ..., A'_n,P'_2,...,P'_m
    \end{align*}
    are the results of applying the
    substitution which unfies $Q$ to $C$ and $P_1$ to $A_1$ to
    \begin{align*}
        A_2,...,A_n,P_2,...,P_m.
    \end{align*}
\end{definition}

\begin{definition}
    Applying \texttt{drule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $P_1$ and $A_1$ can be \emph{unified}, we generate the goals
    \begin{align*}
        \db{A'_2; ...; A'_n} &\Rightarrow P'_2\\
        &\vdots \\
        \db{A'_2; ...; A'_n} &\Rightarrow P'_m\\
        \db{Q',A'_2; ...; A'_n} &\Rightarrow C'
    \end{align*}
    where \begin{align*}
        A'_2, ..., A'_n,P'_2,...,P'_m,Q',C'
    \end{align*}
    are the results of applying the
    substitution which unfies $P_1$ and $A_1$ to
    \begin{align*}
        A_2,...,A_n,P_2,...,P_m,Q,C.
    \end{align*}
\end{definition}
\begin{definition}
    Applying \texttt{frule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $P_1$ and $A_1$ can be \emph{unified}, we generate the goals
    \begin{align*}
        \db{A'_1; ...; A'_n} &\Rightarrow P'_1\\
        &\vdots \\
        \db{A'_1; ...; A'_n} &\Rightarrow P'_m\\
        \db{Q',A'_1; ...; A'_n} &\Rightarrow C'
    \end{align*}
    where \begin{align*}
        A'_1, ..., A'_n,P'_1,...,P'_m,Q',C'
    \end{align*}
    are the results of applying the
    substitution which unfies $P_1$ and $A_1$ to
    \begin{align*}
        A_1,...,A_n,P_1,...,P_m,Q,C.
    \end{align*}
\end{definition}

\begin{definition}
    Applying \texttt{cut\_tac lemmaName} adds the conclusion of \texttt{lemmaName} as a
    new assumption, and its assumptions as new subgoals.
\end{definition}

\begin{definition}
    Applying \texttt{subgoal\_tac $P$} adds $P$ as a new assumption, and introduces $P$
    as a new subgoal.
\end{definition}

\begin{theorem}
    Propositional logic in Isabelle is sound.
\end{theorem}
\begin{proof}
    By the following properties.
    \begin{enumerate}
        \item Every proof is broken down into primitive rules applications which are checked
            by a small piece of hand-verified code. These rules are sound.
        \item New concepts are introduced by definition rather than axiomatisation. New 
            definitions cannot introduce unsoundness.
    \end{enumerate}
\end{proof}

\section{First-Order Logic}

\subsection{Syntax}

\begin{definition}
    Let 
    \begin{itemize}
        \item $\mathcal{V}$ an at most countable set of variables, and
        \item $\mathcal{F}$ an at most countable set of function letters each assigned a unique arity
    \end{itemize} 
    then the set of \emph{well-formed terms} is the smallest set such that
    \begin{itemize}
        \item any variable $v\in \mathcal{V}$ is a term, and
        \item if $f\in \mathcal{F}$ has arity $n$, and $t_1,...,t_n$ are terms, so is $f(t_1, ..., t_n)$.
    \end{itemize}
\end{definition}

\begin{definition}
    Let $P$ an at most countable set of predicats, each assigned a unique arity,
    then the set of \emph{well-formed formulas} is the smallest set such that
    \begin{itemize}
        \item if $A\in \mathcal{P}$ has arity $n$, and $t_1,...,t_n$ are terms, then $A(t_1, ..., t_n)$ is a wff,
        \item if $P$ and $Q$ are wffs, so are $\neg P,P\vee Q,P\wedge Q,P\rightarrow Q,P\leftrightarrow Q$,
        \item if $P$ is a wff, so are $\exists x. P$ and $\forall x. P$ for any $x\in \mathcal{V}$, and
        \item if $P$ is a wff, then $(P)$ is a wff.
    \end{itemize}
\end{definition}

\begin{definition}
    A variable occurence of $x$ is \emph{in the scope of} a quantifier 
    occurence $\forall x$ or $\exists x$ if the quantifier occurence is
    the first occurence of the quantifier over $x$ in a traversal from the 
    variable occurence position to the root of the formula tree.

    An occurence of a variable $x$ in a formula $P$ is \emph{bound} if it
    is in the scope of a $\forall x$ or $\exists x$ quantifier.
\end{definition}

\begin{definition}
    If $P$ is a formula, $s$ is a term and $x$ is a variable, then 
    \begin{align*}
        P[s/x]
    \end{align*}
    is the formula obtained by \emph{substituting $s$ for all free occurences of $x$}
    throughout $P$.
\end{definition}

\subsection{Semantics}

\begin{definition}[Assignment]
    Given an interpretation $\mathcal{I}$, an \emph{assignment $s$} assigns a value
    from the domain $\mathcal{D}$ to each variable $\mathcal{V}$ i.e. $s:\mathcal{V}\to\mathcal{D}$.

    We extend this assignment $s$ to all terms inducively by saying that
    \begin{enumerate}
        \item if $\mathcal{I}$ maps the $n$-ary function letter $f$ to the function $f^\mathcal{I}$, and
        \item if terms $t_1, ..., t_n$ have been assigned concrete values $a_1,...,a_n\in D$
    \end{enumerate}
    then we can assign value $f^\mathcal{I}(a_1,...,a_n)\in\mathcal{D}$ to the term
    $f(t_1,...,t_n)$.
\end{definition}

\begin{definition}[Satisfaction]
    Given an interpretation $\mathcal{I}$ and an assignment $s:\mathcal{V}\to\mathcal{D}$
    \begin{enumerate}
        \item any wff which is a nullary predicate letter $A$ is satisfied iff the
            interpretation of $A$ in $\mathcal{I}$ is $T$,
        \item suppose we have a wff $P$ of the form $A(t_1,..., t_n)$, where $A$ is
            interpreted as relation $A^\mathcal{I}$ and $t_1,...,t_n$ have been assigned
            concrete values $a_1,...,a_n$ by $s$. Then $P$ is satisfied iff \begin{align*}
                (a_1,...,a_n)\in A^\mathcal{I},
            \end{align*}
        \item any wff of the form $\forall x.P$ is satisfied iff $P$ is satisfied with
            with respect to the assignment $s[x\mapsto a]$ for all $a\in D$,
        \item any wff of the form $\exists x.P$ is satisfied iff $P$ is satisfied with
            with respect to the assignment $s[x\mapsto a]$ for some $a\in D$,
        \item any wffs of the form $P\vee Q$, $P\wedge Q$, $P\rightarrow Q$, $P\leftrightarrow Q$,
            $\neg P$ are satisfied according to the truth-tables for each connective.
    \end{enumerate} 
\end{definition}

\begin{definition}[Entailment]
    We write $I\vDash_s P$ to mean that wff $P$ is satisfied by interpretation $I$ and
    assignment $s$.  We say that the wffs $P_1,...,P_n$ \emph{entail} wff $Q$ and write
    \begin{align*}
        P_1,...,P_n\vDash Q
    \end{align*}
    if, for any interpretation $I$ and assignment $s$ for which $I\vDash_s P^i$ for all $i$,
    we also have $I\vDash_s Q$.
\end{definition}

\subsection{Deduction}

\begin{definition}
    The introduction rules for quantifiers are:
    \begin{itemize}
        \item Universal quantification, provided that $x_0$ is not free in the assumptions, \begin{align*}
            \infer[(\text{allI})]{\forall x. P}{P[x_0/x]}
        \end{align*}
        \item Existential qunatification \begin{align*}
            \infer[(\text{exI})]{\exists x.P}{P[t/x]}
        \end{align*}
    \end{itemize}
\end{definition}

\begin{definition}
    The elimination rules for quantifiers are:
    \begin{itemize}
        \item Existential elimination: \begin{align*}
            \infer[(\text{exE})]{Q}{\exists x.P\hs \begin{array}[b]{c}
                [P[x_0/x]]\\
                \vdots \\
                Q
            \end{array}}
        \end{align*}
        \item Specialisation: \begin{align*}
            \infer[(\text{spec})]{P[t/x]}{\forall x.P}
        \end{align*}
        \item Universal elimination: \begin{align*}
            \infer[(\text{allE})]{Q}{\forall x.P\hs \begin{array}[b]{c}
                [P[t/x]]\\
                \vdots \\
                Q
            \end{array}}
        \end{align*}
    \end{itemize}
\end{definition}

\section{Higher-Order Logic}

\subsection{Functions}

\begin{definition}
    A \emph{lambda abstraction} is a term that denotes a function directly by the 
    rules which define it.
\end{definition}

\begin{definition}
    The basic types in Isabelle are \emph{bool}, \emph{ind} and $\alpha\Rightarrow\beta$.
    The two primitive families of functions are:
    \begin{align*}
        &(=_\alpha): \alpha\Rightarrow \alpha \Rightarrow \textit{bool}\\
        &(\rightarrow): \textit{bool} \Rightarrow\textit{bool}\Rightarrow\textit{bool}
    \end{align*}
\end{definition}

\begin{definition}
    The following representations and definitions are used:
    \begin{itemize}
        \item Formulas are terms of type \textit{bool}.
        \item Predicates are functions of type $\alpha\Rightarrow\textit{bool}$.
        \item Sets are represented as predicates.
        \item True is defined as $\top \equiv (\lambda x.x)=(\lambda x.x)$.
        \item Universal quantification as function equality: \begin{align*}
            \forall x. \phi \equiv (\lambda x. \phi) = (\lambda x. \top).
        \end{align*}
        \item Conjunction and disjunction are defined as: \begin{align*}
            P\wedge Q &\equiv \forall R. (P\rightarrow Q \rightarrow R) \rightarrow R\\
            P\vee Q &\equiv \forall R. (P\rightarrow R)\rightarrow (Q\rightarrow R) \rightarrow R
        \end{align*}
    \end{itemize}
\end{definition}

\end{document}