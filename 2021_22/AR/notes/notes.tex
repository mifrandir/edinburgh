\documentclass{article}
\usepackage{notes-preamble}
\usepackage{enumitem}
\mkthms

\title{Automated Reasoning (SEM5)}
\author{Franz Miltz}
\begin{document}
\maketitle
\tableofcontents
\pagebreak
\section{Introduction}
\begin{definition}
    \emph{Automated Reasoning} refers to reasoning in a computer using logic.
    \begin{itemize}
        \item active area of research since the 50s
        \item part of artificial intelligence
    \end{itemize}
\end{definition}
\begin{theorem}
    Formalised mathematics is neither
    \begin{itemize}
        \item \emph{complete} (see G\"odel's Incompleteness Theorems), nor
        \item \emph{decidable} (see Church and Turing).
    \end{itemize}
\end{theorem}

\section{Propositional Logic}

\begin{definition}
    A syntactically correct formula is called a \emph{well-formed formula}.

    Given an alphabet of propositional symbols $\mathcal{L}$, the
    set of wffs is the smallest set such that 
    \begin{itemize}
        \item any symbol $A\in\mathcal{L}$ is a wff;
        \item if $P$ and $Q$ are wffs, so are $\neg P, P\vee Q, P\wedge Q, P\rightarrow Q$, and $P\leftrightarrow Q$;
        \item if $P$ is a wff, then $(P)$ is a wff.
    \end{itemize}
\end{definition}

\begin{definition}
    An \emph{interpretation} (or \emph{valuation}) $V$ is a truth assignment
    to the symbols in the alphabet $\mathcal{L}$, i.e. a function
    \begin{align*}
        V:\mathcal{L}\to \{\top,\bot\}.
    \end{align*}
\end{definition}

\begin{definition}
    An interpretation $V$ \emph{satisfies} a wff $P$ if $[\![ P]\!]_V=\top$.
\end{definition}

\begin{definition}
    A wff is \emph{satisfiable} if there exists an interpretation that satisfies it.
    Otherwise it's unsatisfiable.
\end{definition}

\begin{definition}
    A wff is \emph{valid} if every interpretation satisfies it.
\end{definition}

\begin{definition}
    The wffs $P_1, P_2,...,P_n$ \emph{entail} $Q$ if any interpretation
    which satisfies all of $P_1, P_2,...,P_n$ also satisfies $A$.
    We write 
    \begin{align*}
        P_1, P_2, ..., P_n \vDash Q.
    \end{align*}
\end{definition}

\subsection{Natural deduction}


\begin{definition}
    \emph{Natural deduction} uses the following rules:
    \begin{align*}
        \begin{array}{c c c}
            \infer[(\text{conjI})]{P\wedge Q}{P\hs Q} &
            \infer[(\text{conjunct1})]{P}{P\wedge Q} &
            \infer[(\text{conjunct2})]{Q}{P\wedge Q} \\
            \infer[(\text{disjI1})]{P\vee Q}{P} &
            \infer[(\text{disjI2})]{P\vee Q}{Q} &
            \infer[(\text{disjE})]{R}{P\vee Q \hs \begin{array}[b]{c}
                [P]\\ \vdots \\ R
            \end{array}
            \hs \begin{array}[b]{c}
                [Q]\\ \vdots \\ R
            \end{array}}\\
            \infer[(\text{impI})]{P\to Q}{\begin{array}[b]{c}
                [P]\\\vdots\\Q 
            \end{array}} &
            \infer[(\text{impE})]{R}{P\to Q\hs P \hs \begin{array}[b]{c}
                [Q]\\\vdots\\R
            \end{array}}&
            \infer[(\text{mp})]{Q}{P\to Q\hs P}\\
            \infer[(\text{iffI})]{P\leftrightarrow Q}{\begin{array}[b]{c}
                [Q]\\\vdots\\P
            \end{array}\hs\begin{array}[b]{c}
                [P]\\\vdots\\Q
            \end{array}} &
            \infer[(\text{iffD1})]{Q}{P\leftrightarrow Q\hs P}&
            \infer[(\text{iffD2})]{P}{P\leftrightarrow Q\hs Q}\\
            \infer[(\text{notI})]{\neg P}{\begin{array}[b]{c}
                P \\ \vdots \\ \bot
            \end{array}} &
            \infer[(\text{notE})]{\bot}{P\hs\neg P} & \\
            \infer[(\text{excluded\_middle})]{\neg P \vee P}{} &
            \infer[\text{(ccontr)}]{P}{\begin{array}[b]{c}
                [\neg P] \\ \vdots \\ \bot
            \end{array}}
        \end{array}
    \end{align*}
\end{definition}

\begin{theorem}[Soundness]
    If $Q$ is provable from assumptions $P_1,...,P_2$ then $P_1,...,P_n\vDash Q$. 
\end{theorem}
\begin{theorem}[Completeness]
    If $P_1,...,P_n\vDash Q$ then $Q$ is provable from assumptions $P_1,...,P_2$. 
\end{theorem}

\subsection{Propositional Reasoning in Isabelle}

\newcommand{\db}[1]{[\![#1]\!]}

\begin{definition}
    Applying \texttt{rule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $Q$ and $C$ can be \emph{unified}, we generate the goals
    \begin{align*}
        \db{A'_1; ...; A'_n} &\Rightarrow P'_1\\
        &\vdots \\
        \db{A'_1; ...; A'_n} &\Rightarrow P'_m
    \end{align*}
    where \begin{align*}
        A'_1, ..., A'_n,P'_1,...,P'_m
    \end{align*}
    are the results of applying the
    substitution which unfies $Q$ and $C$ to
    \begin{align*}
        A_1,...,A_n,P_1,...,P_m.
    \end{align*}
\end{definition}

\begin{definition}
    Applying \texttt{erule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $Q$ and $C$ are unifiable and $P_1$ and $A_1$ are unifiable, we generate the goals
    \begin{align*}
        \db{A'_2; ...; A'_n} &\Rightarrow P'_2\\
        &\vdots \\
        \db{A'_2; ...; A'_n} &\Rightarrow P'_m
    \end{align*}
    where \begin{align*}
        A'_2, ..., A'_n,P'_2,...,P'_m
    \end{align*}
    are the results of applying the
    substitution which unfies $Q$ to $C$ and $P_1$ to $A_1$ to
    \begin{align*}
        A_2,...,A_n,P_2,...,P_m.
    \end{align*}
\end{definition}

\begin{definition}
    Applying \texttt{drule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $P_1$ and $A_1$ can be \emph{unified}, we generate the goals
    \begin{align*}
        \db{A'_2; ...; A'_n} &\Rightarrow P'_2\\
        &\vdots \\
        \db{A'_2; ...; A'_n} &\Rightarrow P'_m\\
        \db{Q',A'_2; ...; A'_n} &\Rightarrow C'
    \end{align*}
    where \begin{align*}
        A'_2, ..., A'_n,P'_2,...,P'_m,Q',C'
    \end{align*}
    are the results of applying the
    substitution which unfies $P_1$ and $A_1$ to
    \begin{align*}
        A_2,...,A_n,P_2,...,P_m,Q,C.
    \end{align*}
\end{definition}
\begin{definition}
    Applying \texttt{frule someRule} where
    \begin{align*}
        \texttt{someRule} : \db{P_1;...,;P_m} \Rightarrow Q
    \end{align*}
    to the goal
    \begin{align*}
        \db{A_1; ...; A_n} \Rightarrow C
    \end{align*}
    where $P_1$ and $A_1$ can be \emph{unified}, we generate the goals
    \begin{align*}
        \db{A'_1; ...; A'_n} &\Rightarrow P'_1\\
        &\vdots \\
        \db{A'_1; ...; A'_n} &\Rightarrow P'_m\\
        \db{Q',A'_1; ...; A'_n} &\Rightarrow C'
    \end{align*}
    where \begin{align*}
        A'_1, ..., A'_n,P'_1,...,P'_m,Q',C'
    \end{align*}
    are the results of applying the
    substitution which unfies $P_1$ and $A_1$ to
    \begin{align*}
        A_1,...,A_n,P_1,...,P_m,Q,C.
    \end{align*}
\end{definition}

\begin{definition}
    Applying \texttt{cut\_tac lemmaName} adds the conclusion of \texttt{lemmaName} as a
    new assumption, and its assumptions as new subgoals.
\end{definition}

\begin{definition}
    Applying \texttt{subgoal\_tac $P$} adds $P$ as a new assumption, and introduces $P$
    as a new subgoal.
\end{definition}

\begin{theorem}
    Propositional logic in Isabelle is sound.
\end{theorem}
\begin{proof}
    By the following properties.
    \begin{enumerate}
        \item Every proof is broken down into primitive rules applications which are checked
            by a small piece of hand-verified code. These rules are sound.
        \item New concepts are introduced by definition rather than axiomatisation. New 
            definitions cannot introduce unsoundness.
    \end{enumerate}
\end{proof}

\section{First-Order Logic}

\subsection{Syntax}

\begin{definition}
    Let 
    \begin{itemize}
        \item $\mathcal{V}$ an at most countable set of variables, and
        \item $\mathcal{F}$ an at most countable set of function letters each assigned a unique arity
    \end{itemize} 
    then the set of \emph{well-formed terms} is the smallest set such that
    \begin{itemize}
        \item any variable $v\in \mathcal{V}$ is a term, and
        \item if $f\in \mathcal{F}$ has arity $n$, and $t_1,...,t_n$ are terms, so is $f(t_1, ..., t_n)$.
    \end{itemize}
\end{definition}

\begin{definition}
    Let $P$ an at most countable set of predicats, each assigned a unique arity,
    then the set of \emph{well-formed formulas} is the smallest set such that
    \begin{itemize}
        \item if $A\in \mathcal{P}$ has arity $n$, and $t_1,...,t_n$ are terms, then $A(t_1, ..., t_n)$ is a wff,
        \item if $P$ and $Q$ are wffs, so are $\neg P,P\vee Q,P\wedge Q,P\rightarrow Q,P\leftrightarrow Q$,
        \item if $P$ is a wff, so are $\exists x. P$ and $\forall x. P$ for any $x\in \mathcal{V}$, and
        \item if $P$ is a wff, then $(P)$ is a wff.
    \end{itemize}
\end{definition}

\begin{definition}
    A variable occurence of $x$ is \emph{in the scope of} a quantifier 
    occurence $\forall x$ or $\exists x$ if the quantifier occurence is
    the first occurence of the quantifier over $x$ in a traversal from the 
    variable occurence position to the root of the formula tree.

    An occurence of a variable $x$ in a formula $P$ is \emph{bound} if it
    is in the scope of a $\forall x$ or $\exists x$ quantifier.
\end{definition}

\begin{definition}
    If $P$ is a formula, $s$ is a term and $x$ is a variable, then 
    \begin{align*}
        P[s/x]
    \end{align*}
    is the formula obtained by \emph{substituting $s$ for all free occurences of $x$}
    throughout $P$.
\end{definition}

\subsection{Semantics}

\begin{definition}[Assignment]
    Given an interpretation $\mathcal{I}$, an \emph{assignment $s$} assigns a value
    from the domain $\mathcal{D}$ to each variable $\mathcal{V}$ i.e. $s:\mathcal{V}\to\mathcal{D}$.

    We extend this assignment $s$ to all terms inducively by saying that
    \begin{enumerate}
        \item if $\mathcal{I}$ maps the $n$-ary function letter $f$ to the function $f^\mathcal{I}$, and
        \item if terms $t_1, ..., t_n$ have been assigned concrete values $a_1,...,a_n\in D$
    \end{enumerate}
    then we can assign value $f^\mathcal{I}(a_1,...,a_n)\in\mathcal{D}$ to the term
    $f(t_1,...,t_n)$.
\end{definition}

\begin{definition}[Satisfaction]
    Given an interpretation $\mathcal{I}$ and an assignment $s:\mathcal{V}\to\mathcal{D}$
    \begin{enumerate}
        \item any wff which is a nullary predicate letter $A$ is satisfied iff the
            interpretation of $A$ in $\mathcal{I}$ is $T$,
        \item suppose we have a wff $P$ of the form $A(t_1,..., t_n)$, where $A$ is
            interpreted as relation $A^\mathcal{I}$ and $t_1,...,t_n$ have been assigned
            concrete values $a_1,...,a_n$ by $s$. Then $P$ is satisfied iff \begin{align*}
                (a_1,...,a_n)\in A^\mathcal{I},
            \end{align*}
        \item any wff of the form $\forall x.P$ is satisfied iff $P$ is satisfied with
            with respect to the assignment $s[x\mapsto a]$ for all $a\in D$,
        \item any wff of the form $\exists x.P$ is satisfied iff $P$ is satisfied with
            with respect to the assignment $s[x\mapsto a]$ for some $a\in D$,
        \item any wffs of the form $P\vee Q$, $P\wedge Q$, $P\rightarrow Q$, $P\leftrightarrow Q$,
            $\neg P$ are satisfied according to the truth-tables for each connective.
    \end{enumerate} 
\end{definition}

\begin{definition}[Entailment]
    We write $I\vDash_s P$ to mean that wff $P$ is satisfied by interpretation $I$ and
    assignment $s$.  We say that the wffs $P_1,...,P_n$ \emph{entail} wff $Q$ and write
    \begin{align*}
        P_1,...,P_n\vDash Q
    \end{align*}
    if, for any interpretation $I$ and assignment $s$ for which $I\vDash_s P^i$ for all $i$,
    we also have $I\vDash_s Q$.
\end{definition}

\subsection{Deduction}

\begin{definition}
    The introduction rules for quantifiers are:
    \begin{itemize}
        \item Universal quantification, provided that $x_0$ is not free in the assumptions, \begin{align*}
            \infer[(\text{allI})]{\forall x. P}{P[x_0/x]}
        \end{align*}
        \item Existential qunatification \begin{align*}
            \infer[(\text{exI})]{\exists x.P}{P[t/x]}
        \end{align*}
    \end{itemize}
\end{definition}

\begin{definition}
    The elimination rules for quantifiers are:
    \begin{itemize}
        \item Existential elimination: \begin{align*}
            \infer[(\text{exE})]{Q}{\exists x.P\hs \begin{array}[b]{c}
                [P[x_0/x]]\\
                \vdots \\
                Q
            \end{array}}
        \end{align*}
        \item Specialisation: \begin{align*}
            \infer[(\text{spec})]{P[t/x]}{\forall x.P}
        \end{align*}
        \item Universal elimination: \begin{align*}
            \infer[(\text{allE})]{Q}{\forall x.P\hs \begin{array}[b]{c}
                [P[t/x]]\\
                \vdots \\
                Q
            \end{array}}
        \end{align*}
    \end{itemize}
\end{definition}

\section{Higher-Order Logic}

\begin{definition}
    A \emph{lambda abstraction} is a term that denotes a function directly by the 
    rules which define it.
\end{definition}

\begin{definition}
    The basic types in Isabelle are \emph{bool}, \emph{ind} and $\alpha\Rightarrow\beta$.
    The two primitive families of functions are:
    \begin{align*}
        &(=_\alpha): \alpha\Rightarrow \alpha \Rightarrow \textit{bool}\\
        &(\rightarrow): \textit{bool} \Rightarrow\textit{bool}\Rightarrow\textit{bool}
    \end{align*}
\end{definition}

\begin{definition}
    The following representations and definitions are used:
    \begin{itemize}
        \item Formulas are terms of type \textit{bool}.
        \item Predicates are functions of type $\alpha\Rightarrow\textit{bool}$.
        \item Sets are represented as predicates.
        \item True is defined as $\top \equiv (\lambda x.x)=(\lambda x.x)$.
        \item Universal quantification as function equality: \begin{align*}
            \forall x. \phi \equiv (\lambda x. \phi) = (\lambda x. \top).
        \end{align*}
        \item Conjunction and disjunction are defined as: \begin{align*}
            P\wedge Q &\equiv \forall R. (P\rightarrow Q \rightarrow R) \rightarrow R\\
            P\vee Q &\equiv \forall R. (P\rightarrow R)\rightarrow (Q\rightarrow R) \rightarrow R
        \end{align*}
    \end{itemize}
\end{definition}

\section{Unification}

\subsection{Matching}

\begin{definition}
    \emph{Matching} is the process of finding an instance of a pattern that is equal to another term.

    Problem: Given two expressions, \emph{pattern} $s$ and \emph{target} $t$, find a subsitution
    \begin{align*}
        s[\phi] \equiv t
    \end{align*}
    where $\equiv$ means that the terms are identical.
\end{definition}

\begin{definition}
    A \emph{disagreement pair} of two expressions $s$ and $t$ is a pair of subexpressions
    which disagree.
\end{definition}

\paragraph{Matching Algorithm}

To match pattern and target given substitution $\phi$:

\begin{enumerate}
    \item If pattern and target are identical then succeed with output $\phi$.
    \item Otherwise, let $\lra{t_1, t_2}$ be the first disagreement pair.
    \item If $t_1$ is a variable then call match on pattern $\{t_2/t_1\}$ and target given $\phi\{t_2/t_1\}$.
    \item Else fail.
\end{enumerate}

\subsection{General unification}

\begin{definition}
    \emph{Unification} is the process of finding a common instance of two terms. 

    Problem: Given two expressions, $s$ and $t$, find subsitutions
    $\phi$ and $\psi$ such that
    \begin{align*}
        s[\phi] \equiv t[\psi]
    \end{align*}
    where $\equiv$ means that the terms are identical.
\end{definition}

\paragraph{Unification algorithm}

To generally unify $S$ given $\phi$
\begin{enumerate}
    \item If $\abs{S}=1$, succeed and output $\phi$.
    \item Otherwise, let $D$ be the first disagreement set of $S$.
    \item If $D$ contains a variable $V$ and a term $t_1$ and $V$ 
          does not occur in $t_1$ then generally unify $S[\{t_1/V\}]$ given $\phi[\{t_1/V\}]$.
    \item Else fail.
\end{enumerate}

\begin{definition}
    We have the following types of unification: 
    \begin{enumerate}
        \item \emph{unitary}: A single unique mgu, or none. (predicate logic)
        \item \emph{finitary}: Finite number of mgus. (predicate logic with commutativity)
        \item \emph{infinitary}: Possibly infinite number of mgus. (predicate logic with associativity)
        \item \emph{nullary}: No mgus exist, although unifiers may exist.
        \item \emph{undecidable}: Unification is not decidable.
    \end{enumerate}
\end{definition}

\begin{center}
    \begin{tabular}{c | c | c | c}
        \textbf{Name}   & \textbf{Before}                        & \textbf{After}                           & \textbf{Condition}                         \\\hline
        Decompose       & $P\wedge (f(\vec s) \equiv f(\vec t))$ & $P\wedge\bigwedge_i (s_i \equiv t_i)$    &                                            \\\hline
        Conflict        & $P\wedge (f(\vec s) \equiv g(\vec t))$ & fail                                     & $f\not\equiv g$                            \\\hline
        Switch          & $P\wedge (s\equiv X)$                  & $P\wedge(X\equiv s)$                     & $X\in V$, $s\not\in V$                     \\\hline
        Delete          & $P\wedge (s\equiv s)$                  & P                                        &                                            \\\hline
        Eliminate       & $P\wedge (X\equiv s)$                  & $P[s/X]\wedge X\equiv s$                 & $X\in V(P)$, $X\not\in V(s)$, $s\not\in V$ \\\hline
        Occurs Check    & $P\wedge (X\equiv s)$                  & fail                                     & $X\in V(s)$, $s\not\in V$                  \\\hline
        Coalesce        & $P\wedge (X\equiv Y)$                  & $P[Y/X]\wedge(X\equiv Y)$                & $X,Y\in V(P)$, $X\not\equiv Y$
    \end{tabular}
\end{center}

\subsection{Composition of subsitutions}

\begin{definition}
    If $\phi$ and $\psi$ are subsitutions then their \emph{composition $\phi\circ\psi$}
    is also a subsitution which, for any term $t$, satisfies the following property:
    \begin{align*}
        t[\phi\circ\psi] \equiv (t[\phi])[\psi].
    \end{align*}
\end{definition}

\begin{definition}
    We say two subsitutions $\phi$, $\psi$ are equal if for all variables $x$,
    \begin{align*}
        x[\phi] = x[\psi].
    \end{align*}
\end{definition}

\begin{theorem}
    The set of all subsitutions together with the operation $\circ$ forms a monoid. In particular,
    for any substitutions $\phi,\psi,\theta$ and any variable $x$, we have 
    \begin{itemize}
        \item \emph{associativity}: $(\phi \circ \psi) \circ \theta = \phi \circ (\psi \circ \theta)$,
        \item \emph{unit}: $\phi\circ[] = \phi = []\circ\phi$.
    \end{itemize}
\end{theorem}

\begin{definition}
    Given any two terms $s$ and $t$, a subsitution $\phi$ is their \emph{most general unifier}
    if 
    \begin{align*}
        s[\phi]\equiv t[\phi] \hs\text{and}\hs
        \forall \psi.\: s[\psi] \equiv t[\psi]  \Rightarrow \exists \theta.\: \psi = \phi \circ \theta.
    \end{align*}
\end{definition}

\begin{theorem}
    The \emph{most general unifier} is unique up to alphabetic variance.
\end{theorem}

\paragraph{Combining subsitutions}

To combine subsitutions $\phi$ and $\psi$
\begin{enumerate}
    \item Replace each pair $s/X$ in $\phi$ by $s\psi/X$ to form $\phi'$.
    \item Delete from $\phi$ each pair $t_1/Y$ such that $\phi'$ contains a pair $s/Y$ to form $\psi'$.
    \item Output the union of $\phi'$ and $\psi'$.
\end{enumerate}

\section{Rewriting}

\subsection{Definition}

\begin{definition}
    \emph{Rewriting} is a technique for replacing terms in an expression with equivalent terms.
\end{definition}

\begin{theorem}[Rewrite rule of inference]
    \begin{align*}
        \infer{P\{R[\theta]\}}{P\{t\}\hs L\Rightarrow R\hs L[\theta]=t}
    \end{align*} 
\end{theorem}

\begin{definition}
    A rewrite rule $\alpha\Rightarrow\beta$ must satisfy the following restrictions:
    \begin{itemize}
        \item $\alpha$ is not a variable.
        \item $V(\beta)\subseteq V(\alpha)$.
    \end{itemize}
\end{definition}

\subsection{Termination}

\begin{definition}
    We say that a set of rewrite rules is \emph{terminating} if starting with any expression,
    successively applying rewrite rules eventually brings us to a state where no rule applies. 
\end{definition}

\begin{theorem}
    Suppose we have a measure $M$ that assigns to every expression a nonnegative integer and
    a set of rewrite rules $S$. If every rule in $S$ decreases the value of $M$, then $S$ 
    is terminating.
\end{theorem}

\end{document}