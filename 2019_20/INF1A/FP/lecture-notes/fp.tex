\documentclass{article}
\usepackage{notes-preamble}
\begin{document}
\title{INF1A: Introduction to Computation (SEM1)}
\author{Franz Miltz}
\date{07 September 2019}
\maketitle
\tableofcontents
\pagebreak
\section{Lecture 0, September 16 (FP + CL)}
\subsection{Reading}
\subsection{Tutorial}
\begin{itemize}
    \item do exercise before
    \item collaboration is fine
    \item no marks
    \item mandatory to not fail the exam
\end{itemize}
\begin{itemize}
    \item look at Piazza forum
\end{itemize}
\subsection{Ethics}
Think about your impact on the world.\\
Think about your own prejudices:
\url{https://implicit.harvard.edu/implicit}
\section{Lecture 1 (FP), September 17}
\subsection{Prolog}
\begin{itemize}
    \item Tutorials start this week. (Thursday/Friday)
    \item Everyone should install Haskell.
    \item Get the Tutorial! (May involve extra steps. Sorry.)
    \item You may read in before or after the lecture.
\end{itemize}
\subsection{Why FP first?}
\begin{itemize}
    \item Diversity is important.
    \item Increasingly important.
    \item Equality throughout the course.
    \item Operate on data structure \emph{as a whole} rather than \emph{piecemeal}. $\Rightarrow$ higher level
    \item Good for councurrency.
    $\Leftarrow$ Everything is immutable.
    You don't need to worry about different instances changing the data.
\end{itemize}
Quote of the day:
\begin{quotation}
    Premature optimization is the root of all evil.
    (Philip Wadler)
\end{quotation}
\subsection{What is Haskell?}
\begin{itemize}
    \item A functional programming language
    \item Designed by a committee 30 years ago.
    \item Phil was part of it.
\end{itemize}
\subsection{What is Haskell for?}
\begin{itemize}
    \item Research
    \item Teaching
    \item Industry
\end{itemize}
\subsection{Families}
\begin{itemize}
    \item FP: Haskell, Erlang, Purescript, Racket, Scala
    \item OO: C++, Java, C\#, Python
\end{itemize}
Ideas from FP have found their way into OOP. (GC, Higher-order functions, generics, list comprehension, ...)
\subsection{Functions}
\subsubsection{Definitions}
\begin{itemize}
    \item Recipe / Instructions
    \item I/O pair set
    \item equation
    \item a graph
\end{itemize}
\subsubsection{Kinds of data}
\begin{itemize}
    \item integers
    \item floats
    \item characters
    \item strings
    \item booleans
    \item pictures
\end{itemize}
\subsubsection{Applying a function}
\begin{minted}{haskell}
invert :: Picture -> Picture
knight :: Picture
invert knight
\end{minted}
\subsubsection{Composing functions}
\begin{minted}{haskell}
beside :: Picture -> Picture -> Picture
flipV  :: Picture -> Picture
invert :: Picture -> Picture
knight :: Picture -> Picture

beside (invert knight) (flipV knight)
\end{minted}
Composing: "Build bigger things out of littler things."\\
(Use function outputs directly as inputs for other functions.)
\section{Lecture 2 (FP), September 19}
\subsubsection{Defining a new function}
\begin{minted}{haskell}
double :: Picture -> Picture
double p = beside (invert p) (flipV p)

double knight
\end{minted}
$\Rightarrow$ Function abstraction: Define a function for an operation to reuse it.\\\\
Phils definition of abstraction: Don't concern yourself with details you don't need to worry about yet.
\subsubsection{Terminology}
Type signature:
\begin{minted}{haskell}
double :: Picture -> Picture
\end{minted}
Function declaration:
\begin{minted}{haskell}
double p = beside (invert p) (flipV p) -- function definition
double knight                          -- expression
\end{minted}
\begin{itemize}
    \item \texttt{double}: function name
    \item \texttt{p}: formal parameter
    \item \texttt{beside (invert p) (flipV p)}: function body
    \item \texttt{knight}: actual parameter
\end{itemize}
Tip: Always define types beforehand.
\subsection{List and Comprehensions}
\subsubsection{Lists}
\begin{itemize}
    \item ordered
    \item same type
    \item allows duplicates
\end{itemize}
\subsubsection{List comprehensions}
\begin{itemize}
    \item Generator: where the values come from
    \item Guard: Condition for when to take an element from the generator
\end{itemize}
\section{Lecture 3 (FP), September 20}
\subsubsection{Cons and append}
\begin{minted}{haskell}
(:)  :: a -> [a] -> [a]   -- cons
(++) :: [a] -> [a] -> [a] -- append
\end{minted}
\subsubsection{More Lists}
A recursive defintion of lists:
\begin{itemize}
    \item empty, written \texttt{[]}, or
    \item contstructed, written \texttt{x:xs}, with head x and tail xs.
\end{itemize}
\subsection{Recursion}
Defining something in terms of itself.
You need:
\begin{itemize}
    \item base case
    \item recursive case
\end{itemize}
\begin{minted}{haskell}
sqauresRec :: [Int] -> [Int]
sqauresRec [] = []
squaresRec (x:xs) = x*x : squaresRec xs
\end{minted}
\section{Lecture 4 (FP), September 30}
Counting:
\begin{minted}{haskell}
enumFromTo :: Int -> Int -> [Int]
enumFromTo m n
    | m > n = []
    | otherwise = m : enumFromTo (m+1) n
\end{minted}
A trick with \texttt{zip}:
\begin{minted}{haskell}
*Main> zip [0..] "abcdef" = [(0, 'a'), (1, 'b'), ...]
\end{minted}
\section{Lecture 5, October 01}
\subsection{Select, take and drop}
\begin{minted}{haskell}
Prelude> "words" !! 3
'd'
Prelude> take 3 "words"
"wor"
Prelude> drop 3 "words"
"ds"
\end{minted}
Select with list comprehension:
\begin{minted}{haskell}
selectComp :: [a] -> Int -> a
selectComp xs i = the [x | (j,x) <- zip [0..] xs, i==j]
  where
  the [x] = x
\end{minted}
Take with list comprehension:
\begin{minted}{haskell}
takeComp :: Int -> [a] -> [a]
takeComp i xs = [x | (j,x) <- zip [0..] xs, j<i]
\end{minted}
Drop with list comprehension:
\begin{minted}{haskell}
dropComp :: Int -> [a] -> [a]
dropComp i xs = [x | (j,x) <- zip [0..] xs, j>=i]
\end{minted}
Select, take and drop using recursion:
\begin{minted}{haskell}
(!!) :: [a] -> Int -> a
(x:xs) !! 0 = x
(x:xs) !! i = xs !! (i-1)

take :: Int -> [a] -> [a]
take 0 xs = []
take i [] = []
take i (x:xs) = x : take (i-1) xs

drop :: Int -> [a] -> [a]
drop 0 xs = xs
drop i [] = []
drop i (x:xs) = drop i-1 xs
\end{minted}
\section{Lecture 6, October 07}
\subsection{Map}
\begin{minted}{haskell}
squares :: [Int] -> [Int]
squares xs = map sqr xs
    where sqr x = x * x
ords :: [Char] -> [Int]
ords xs = map ord xs
incs :: [Int] -> [Int]
incs xs = map (5+) xs
\end{minted}
\subsection{Filter}
\begin{minted}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
filter p xs = [x | x <- xs, p x]
digits :: [Int] -> [Int]
digits xs = filter isDigit xs
\end{minted}
\subsection{Fold}
\begin{minted}{haskell}
foldr :: (a -> a -> a) -> a -> [a] -> a
foldr f v [] = v
foldr f v (x:xs) = f x (foldr f v xs)
\end{minted}
\section{Lecture 7, October 14}
\subsection{Algebraic types}
\subsubsection{Boolean}
\begin{minted}{haskell}
data Bool = False | True
not :: Bool -> Bool
not False = True
not True  = False

(&&) :: Bool -> Bool -> Bool
False && q = False
True  && q = q

(||) :: Bool -> Bool -> Bool
False || q = q
True  || q = True
\end{minted}
\subsubsection{Seasons}
\begin{minted}{haskell}
data Season = Winter | Spring | Summer | Fall

next       :: Season -> Season
eqSeason   :: Season -> Season -> Bool
showSeason :: Season -> String
toInt      :: Season -> Int
\end{minted}
\subsubsection{Components}
\begin{minted}{haskell}
type Radius = Float
type Width  = Float
type Height = Float

data Shape = Circle Radius | Rect Width Height

area :: Shape -> Float
area (Circle r) = pi*r*r
area (Rect w h) = w*h
\end{minted}
\begin{description}
    \item[Functions] can appear on the right of the equals sign.
    \item[Constructors] are special functions that can appear on the left of the equals sign.
\end{description} 
Tip: Capitalize only constructors.
\subsubsection{Tests and selectors}
isRect :: Shape -> Bool
isRect (Circle r) = False
isRect (Rect w h) = True
\subsubsection{Lists}
\begin{minted}{haskell}
data List a = Nil | Cons a (List a)

append :: List a -> List a -> List a
append Nil ys         = ys
append (Cons x xs) ys = Const x (append xs ys)
\end{minted}
\subsubsection{Natural Numbers}
\begin{minted}{haskell}
data  Nat = Zero | Succ Nat

power :: Float -> Nat -> Float
power x Zero     = 1.0
power x (Succ n) = x * power x n
\end{minted}
\section{Lecture 9, October 15}
\subsection{Expression Trees}
\begin{minted}{haskell}
data Exp = Lit Int | Add Exp Exp | Mul Exp Exp

evalExp :: Exp -> Int
evalExp (Lit x) = x
evalExp (Add x y) = evalExp x + evalExp y
evalExp (Mul x y) = evalExp x * evalExp y
\end{minted}
\section{Lecture 10, October 21}
... 
\section{Lecture 12-13, October 28}
\subsection{Big O-notation and efficiency}
We say $f$ is $O(g)$ when $g$ is an upper bound for $f$, for big enough inputs.\\ 
Only care about how much the worst-time grows, not about the absolute values.

\subsubsection{Parallelism}
If you can make something parallel and have many computer, you should. You might reduce from linear to logarithmic.
\section{Lecture 14}
\subsection{Lazy Evaluation}
\begin{definition}
    A closure is a bit of code, that still needs to be executed unless a return value is found before it's needed.
\end{definition}
\begin{minted}{haskell}
ho :: Int -> [Int]
ho n = (take 1 . filter odd) [0..n]

ho 1000000
= (take 1 . filter odd) [0..1000000]
= take 1 (filter odd [0..1000000])
= take 1 (filter odd (0 : [1..1000000]))
= take 1 (filter odd [1..1000000])
= take 1 (filter odd (1 : [2..1000000]))
= take 1 (1 : (filter odd [2..1000000]))
= 1
\end{minted}
Haskell does not evaluate a data structure unless it needs it.\\
This is not always helpful though, you should wirte your program in a way that makes use of this property.
\subsection{HOF vs. List Comprehension vs. Recursion}
Higher-order functions are almost always faster than list comprehension and recursion. This is due to the effective optimization in the Glasgow Haskell Compiler.
\section{Lecture 15}
\subsection{Type classes}
In
\begin{minted}{haskell}
elem :: Eq a => a -> [a] -> Bool
\end{minted}
\texttt{a} may be any type that implements equality (\texttt{Eq}).\\
\begin{minted}{haskell}
class Eq a where
    (==) :: a -> a -> Bool

instance Eq Int where
    (==) = eqInt

instance Eq Char where
    x == y = ord x == ord y

instance (Eq a, Eq b) => Eq (a, b) where
    (u,v) == (x,y) = (u == x) && (v == y)
\end{minted}
You may also implement type classes:
\begin{minted}{haskell}
elem :: EqDict a -> a -> [a] -> Bool
\end{minted}
\subsection{Eq, Ord, Show}
\begin{minted}{haskell}
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool

class Show a where
    show :: a -> String

instance Eq Bool where
    False == False = True
    False == True  = False
    True  == False = False
    True  == True  = True

instance Show Bool where
    show True  = "True"
    show False = "False"
\end{minted}
For Pairs:
\begin{minted}{haskell}
instance (Eq a, Eq b) => Eq (a,b) where
    (x,y) == (x',y') = x == x' && y == y'

instance (Show a, Show b) => Show (a,b) where
    show (a,b) = "(" + show a + ", " + show b + ")"
\end{minted}
\subsection{Numerical classes}
\begin{minted}{haskell}
class (Eq a, Show a) => Num a where
    (+), (-), (*)   :: a -> a -> a
    negate          :: a -> a
    fromInteger     :: Integer -> a

class (Num a) => Fractional a where
    (/)             :: a -> a -> a
    recip           :: a -> a
    fromRational    :: Rational -> a
\end{minted}
Naturals:
\begin{minted}{haskell}
data Nat = MkNat Integer

invariant :: Nat -> Bool
invariant (MkNat x) = x >= 0

instance Eq Nat where
    MkNat x == MkNat y = x == y

instance Ord Nat where
    MkNat x <= MkNat y == x <= y
\end{minted}
\subsection{Shape}
\begin{minted}{haskell}
instance Eq Shape where
    Circle r == Circle r' = r == r'
    Rect w h == Rect w' h' = w == w'
\end{minted}
\section{Lecture 16-17, November 11}
\subsection{Combinatorics}
\subsubsection{Sublists}
Finding all the sublists of a string:
\begin{minted}{haskell}
subs :: [a] -> [[a]]
subs []     = [[]]
subs (x:xs) = subs xs ++ map (x:) (subs xs)
\end{minted}
The length of subs grows with $O(2^n)$.
\subsubsection{Cartesian Product}
\begin{minted}{haskell}
cp :: [[a]] -> [[a]]
cp []       = [[]]
cp (xs:xss) = [y:ys | y <- xs, ys <- cp xss]
\end{minted}
\subsubsection{Permutations of a list}
\begin{minted}{haskell}
splits :: [a] -> [(a, [a])]
splits xs = [(xs!!k, take k xs ++ drop (k+1) xs) | k <- [0..n-1]]
    where n = length xs

perms :: [a] -> [[a]]
perms [] = [[]]
perms (x:xs) = [y:zs | (y,ys) <- splits (x:xs), zs <- perms ys]
\end{minted}
\subsubsection{Choose k elements from a list}
\begin{minted}{haskell}
choose :: Int -> [a] -> [[a]]
choose 0 []    = [[]]
choose k (x:xs)
    | k == 0         = [[]]
    | k == n         = [x:xs]
    | 0 < k && k < n = choose k xs ++ map (x:) (choose (k-1) xs)
    where n = 1 + length xs
\end{minted}
\section{IO and Monads}
\subsection{Print a character}
\begin{minted}{haskell}
putChar :: Char -> IO ()
\end{minted}
It returns the command which, \emph{if its ever performed}, prints the given character to the standard output.
\subsection{Chain commands}
\begin{minted}{haskell}
(>>) :: IO () -> IO () -> IO ()
\end{minted}
Returns the command that, \emph{if its ever performed}, does what the first command does and then what the second command does.
\subsection{Do nothing}
\begin{minted}{haskell}
done :: IO ()
\end{minted}
Returns the command that, \emph{if its ever performend}, does nothing.
\subsection{Print a string}
\begin{minted}{haskell}
putStr :: String -> IO ()
putStr []     = done
putStr (x:xs) = putChar x >> putStr xs
\end{minted}
So \texttt{putStr "?!"} is equivalent to \texttt{putChar '?' >> putChar '!'}.
\subsection{Higher-order functions}
We can write \texttt{putStr} more elegantly.
\begin{minted}{haskell}
putStr xs = foldr (>>) done $ map putChar xs
\end{minted}
\subsection{Main}
\begin{minted}{haskell}
main :: IO ()
main = putStr "?!"
\end{minted}
Main executes whatever commands it returns.
\subsection{Read a character}
\begin{minted}{haskell}
getChar :: IO Char
\end{minted}
which returns the command that returns a character.
\subsection{Combining commands that have values}
\begin{minted}{haskell}
(>>=) :: IO a -> (a -> IO b) -> IO b
\end{minted}
For example, performing the command
\begin{minted}{haskell}
getChar >>= \x -> putChar (toUpper x)
\end{minted}
whe the input is \texttt{"abc"} produces the output \texttt{"A"}, and the remaining input is \texttt{"bc"}.
\subsection{Special cases}
\begin{minted}{haskell}
done = return ()
m >> n = m >>= \() -> n
\end{minted}
\subsection{Monads and Monoids}
\subsubsection{Monoids}
A \emph{monoid} is a pair of an operator (\texttt{@@}) and a value $u$, where the operator has the value as identity and is associative.
\subsubsection{Monads vs Monoids}
We know that (\texttt{>>}) and \texttt{done} satisfy the laws of a \emph{monoid}.
\subsection{Substitution}
We write \texttt{n[x := v]} to stand for
\begin{center}
    term \texttt{m} with variable \texttt{x} replaced by value \texttt{v]}.
\end{center}
For example, in \texttt{n} is \texttt{x * x} and \texttt{x} is \texttt{x} and \texttt{v} is \texttt{3},
\begin{center}
    \texttt{(x * x) [x := 3] = (3 * 3)}
\end{center}
\subsection{The monad of lists}
In the standard prelude:
\begin{minted}{haskell}
    class Monad m where
        return :: a -> m a
        (>>=)  :: m a -> (a -> m b) -> m b
    
    instance Monad [] where
        [] >>= k = []
        m >> k   = concat (map k m)
\end{minted}
\subsection{Monads with plus}
\begin{minted}{haskell}
    class Monad m => MonadPlus m where
        mzero :: m a
        mplus :: m a -> m a -> m a
    
    instance MonadPlus [] where
        mzero :: [a]
        mzero =  []

        mplus :: [a] -> [a] -> [a]
        mplus = (++)

        guard :: MonadPlus m => Bool -> m ()
        guard False = mzero
        guard True  = return ()

        msum :: MonadPlus m => [m a] -> m a
        msum = foldr mplus mzero
\end{minted}
\end{document}