\documentclass{article}
\usepackage{notes-preamble}
\usepackage{enumitem}
\mkthmstwounified

\title{Introduction to Theoretical Computer Science (SEM6)}
\author{Franz Miltz}
\begin{document}
\maketitle
\noindent Textbook: M. Sipser, \emph{Introduction to the Theory of Computation}
\tableofcontents
\pagebreak

\section{Regular Languages}

\subsection{Finite automata}

\begin{definition*}[DFA; Sipser]
	A \emph{deterministic finite automaton} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
	\begin{enumerate}
		\item $Q$ is a finite set called the \emph{states},
		\item $\Sigma$ is a finite set called the \emph{alphabet},
		\item $\delta:Q\times\Sigma\to Q$ is the \emph{transition function},
		\item $q_0\in Q$ is the \emph{start state}, and
		\item $F\subseteq Q$ is the \emph{set of accept states}.
	\end{enumerate}
\end{definition*}

\begin{definition*}[Formal language; Sipser]
	A \emph{language} $A$ over an alphabet $\Sigma$ is a set such that for all
	$w\in A$ there exist $w_1,w_2,...,w_n\in\Sigma$ such that $w=w_1w_2\cdots w_n$.

	A finite automaton $M=(Q,\Sigma,\delta,q_0,F)$ accepts a word $w=w_1\cdots w_n\in A$
	if there exists a sequence of states $r_0,...,r_n\in Q$ such that
	\begin{enumerate}
		\item $r_0=q_0$,
		\item $\delta(r_i,w_{i+1})=r_{i+1}$, for $i<n$, and
		\item $r_n\in F$.
	\end{enumerate}
	We say $M$ recognises $A$ if and only if $A=\{w : M\text{ accepts }w\}$.
\end{definition*}

\begin{definition*}[Regular language; Sipser]
	A language is called a \emph{regular} if some finite automaton recognises it.
\end{definition*}

\begin{definition*}[Regular operations; Sipser]
	Let $A$ and $B$ be languages. We define the following \emph{regular operations}:
	\begin{enumerate}
		\item \emph{union}: $A\cup B=\{x : x \in A \text{ or } x \in B\}$.
		\item \emph{concatenation}: $A\circ B=\{xy : x \in A \text{ or } y \in B\}$.
		\item \emph{star}: $A^* = \{x_1x_2\dots x_k:k\geq 0 \text{ and each }x_i\in A\}$.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 45, 60, 62]
	The class of regular languages is closed under regular operations.
\end{theorem*}

\begin{theorem*}[Pumping lemma]
	If $A$ is a regular language, then there is a number $p$ where if $s$
	is any string in $A$ of length at least $p$, then $s$ may be divided
	into three pieces, $s=xyz$, satisfying the following conditions:
	\begin{enumerate}
		\item for each $i\geq 0$, $xy^iz\in A$,
		\item $\abs y > 0$, and
		\item $\abs{xy} \leq p$.
	\end{enumerate}
\end{theorem*}

\subsection{Nondeterminism}

\begin{definition*}[NFA; Sipser]
	A \emph{nondeterministic finite automaton} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
	\begin{enumerate}
		\item $Q$ is a finite set called the \emph{states},
		\item $\Sigma$ is a finite set called the \emph{alphabet},
		\item $\delta:Q\times\Sigma\to\mathcal{P}(Q)$ is the \emph{transition function},
		\item $q_0\in Q$ is the \emph{start state}, and
		\item $F\subseteq Q$ is the \emph{set of accept states}.
	\end{enumerate}
\end{definition*}

\begin{definition*}[$\e$-NFA; Sipser]
	An \emph{$\e$-NFA} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
	\begin{enumerate}
		\item $Q$ is a finite set called the \emph{states},
		\item $\Sigma$ is a finite set called the \emph{alphabet},
		\item $\delta:Q\times\Sigma_\e\to \mathcal{P}(Q)$ is the \emph{transition function},
		\item $q_0\in Q$ is the \emph{start state}, and
		\item $F\subseteq Q$ is the \emph{set of accept states}.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 55]
	Let $L$ be a language. Then the following statements are equivalent:
	\begin{enumerate}
		\item $L$ is regular.
		\item There exists a DFA $M$ that recognises $L$.
		\item There exists an NFA $M$ that recognises $L$.
		\item There exists an $\e$-NFA $M$ that recognises $L$.
	\end{enumerate}
\end{theorem*}

\subsection{Regular expressions}

\begin{definition*}[Regular expression]
	$R$ is a \emph{regular expression} over an alphabet $\Sigma$ if one of the following holds:
	\begin{enumerate}
		\item $R\in\Sigma$,
		\item $R=\e$,
		\item $R=\emptyset$,
		\item $R=(R_1\cup R_2)$, where $R_1,R_2$ are regular expressions,
		\item $R=(R_1\circ R_2)$, where $R_1,R_2$ are regular expressions, or
		\item $R=(R_1^*)$, where $R_1$ is a regular expression.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 66]
	A language is regular iff some regular expression describes it.
\end{theorem*}

\section{Context-free languages}

\subsection{Context-free grammars}

\begin{definition*}[CFG; Sipser]
	A \emph{context-free grammar} is a 4-tuple $(V,\Sigma,R,S)$ where
	\begin{enumerate}
		\item $V$ is a finite set called the \emph{variables},
		\item $\Sigma$ is a finite set called the \emph{terminals},
		\item $R\subseteq V\times(V\cup\Sigma)^*$ is a finite set of \emph{rules},
		\item $S\in V$ is the \emph{start variable}.
	\end{enumerate}
\end{definition*}

\begin{definition*}[Context-free language; Sipser]
	Let $G=(V,\Sigma,R,S)$ be a CFG and let $u,v\in(V\cup\Sigma)^*$.
	We say \emph{$u$ derives $v$}, written $u\Rightarrow^* v$, if $u=v$ or if a sequence
	$u_1,...,u_k$ exists for $k\geq 0$ such that
	\begin{align*}
		u\Rightarrow u_1 \Rightarrow ... \Rightarrow u_k \Rightarrow v.
	\end{align*}
	The \emph{language of the grammar} $G$ is $L=\{w\in\Sigma^*:S\Rightarrow^* w\}$,
	called a \emph{context-free language} (CFL).
\end{definition*}

\begin{definition*}[Ambiguitiy; Sipser]
	A string $w$ is derived \emph{ambiguously} in CFG $G$ if it has
	two or more different leftmost derivations. Grammar $G$ is \emph{ambiguous} if it
	generates some string ambiguously.
	A language which is only generated by ambiguous grammars is called \emph{inherently
		ambiguous}.
\end{definition*}

\begin{definition*}[Chomsky normal form; Sipser]
	A CFG $G=(V,\Sigma,R,S)$ is in \emph{Chomsky normal form} if every rule is of the
	form
	\begin{align*}
		A\to BC, \hs
		A\to a, \hs
		S\to\e
	\end{align*}
	where $a\in\Sigma$ and $B,C\in V$
\end{definition*}

\begin{theorem*}[Sipser p. 109]
	Any CFL is generated by a CFG in Chomsky normal form.
\end{theorem*}

\subsection{Pushdown automata}

\begin{definition*}[PDA; Sipser]
	A \emph{pushdown automaton} (PDA) is a 6-tuple $(Q,\Sigma,\Gamma,\delta,q_0,F)$,
	where
	\begin{enumerate}
		\item $Q$ is the finite set of states,
		\item $\Sigma$ is the finite input alphabet,
		\item $\Gamma$ is a finite set called the \emph{stack alphabet},
		\item $\delta:Q\times \Sigma_\e\times\Gamma_\e\to\mathcal{P}(Q\times\Gamma_\e)$ is the transition function,
		\item $q_0\in Q$ is the start state, and
		\item $F\subseteq Q$ is the set of accept states.
	\end{enumerate}
	Let $M=(Q,\Sigma,\Gamma,\delta,q_0,F)$ and $w=w_1\cdots w_m$, where
	$w_1,...,w_m\in\Sigma_\e$. Then $M$ accepts $w$ if there exists a sequence of
	states $r_0,...,r_m\in Q$ and strings $s_0,...,s_m\in\Gamma^*$ such that
	\begin{enumerate}
		\item $r_0=q_0$ and $s_0=\e$,
		\item for $i<m$, we have $(r_{i+1},b)\in\delta(r_i,w_{i+1},a)$, where $s_i=at$
		      and $s_{i+1}=bt$ for some $a,b\in\Gamma_\e$ and $t\in\Gamma^*$,
		\item $r_m\in F$.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 117]
	A language is context-free iff a PDA recognises it.
\end{theorem*}

\begin{corollary*}[Sipser p. 124]
	Every regular language is context-free.
\end{corollary*}

\subsection{Non-context-free languages}

\begin{theorem*}[Pumping lemma for context-free languages; Sipser p. 125]
	If $A$ is a context-free language, then there is a number $p$ where,
	if $s$ is any string in $A$ of length at least $p$, then $s$ may be
	divided into five pieces $s=uvxyz$ such that
	\begin{enumerate}
		\item for each $i\geq 0$ $uv^ixy^iz\in A$,
		\item $\abs{vy}>0$, and
		\item $\abs{vxy}\leq p$.
	\end{enumerate}
\end{theorem*}

\section{Register machines and Turing machines}

\subsection{Programs}

\begin{definition*}[RM]
	A \emph{register machine} (RM) has a fixed number of registers $R_0,...,R_{m-1}$
	which each hold a natural number and a fixed program, i.e. a sequence of
	instructions $P=I_0,...,I_{n-1}$. Each instruction is one of
	\begin{enumerate}
		\item $\inc(i)$, to add $1$ to $R_i$, or
		\item $\decjz(i,j)$, if $R_i=0$ then go to $I_j$, else subtract $1$ from $R_i$.
	\end{enumerate}
	Instructions are exectued instructions in order, except when
	a jump is triggered.
\end{definition*}

\begin{definition*}[RM computation]
	A \emph{state} of a register machien $M$ as above is a tuple $(R_0,...,R_{m-1},C)$
	where $R_i\in\N$ is the value of register $i$, and $0\leq C\leq n$ is the
	\emph{program counter}.

	The next state function is a partial function from states to states, defined
	as follows: if $s=(R_0,...,R_{m-1},C)$ is a state then $\text{next}(s)$ is undefined
	if $C=n$ and otherwise is $s'=(R'_0,...,R'_{m-1},C')$ where
	\begin{itemize}
		\item if $I_C = \inc(i)$ then $C'=C+1$ and $R'_i = R_i + 1$ and $R'_k=R_k$ for $k\not=i$;
		\item if $I_C=\decjz(i,j)$ and $R_i>0$ then $C'=C+1$ and $R'_i=R_i-1$ and $R'_k = k$ for $k\not = i$;
		\item if $I_C=\decjz(i,j)$ and $R_i=0$ then $C'=j$ and $R'_k=R_k$ for all $k$.
	\end{itemize}
	We write $s\to s'$ if $s'=\text{next}(s)$.

	An \emph{input} for $M$ is a tuple $R=(R_0,...,R_{m-1})$ of values for the registers.
	A \emph{run} of $M$ on input $R$ is a sequence of states $(R_0,...,R_{m-1},0)=s_0\to s_1\to\dots$
	such that either the sequence is infinite or the sequence is finite and the final
	state $s_f$ has no next state. The \emph{output} of $M$ on input $R$ is the tuple
	$R'$ of register values in state $s_f$, or undefined if there is no final state.
\end{definition*}

\begin{definition*}[ERM]
	An \emph{extended register machine program} comprises
	\begin{itemize}
		\item A set $L$ of labels,
		\item a sequence $I_0,...,I_{n-1}$ of extended instructions,
		\item a labelling function $\text{lab}:L\to\{0,..,n\}$, and
		\item a list $D_0,...,D_l$ of macro definitions.
	\end{itemize}
	An extended instruction is
	\begin{itemize}
		\item $\inc(i)$ or $\decjz(i,j)$ where $i$ is either an integer or a macro
		      register parameter and $j$ is a non-negative integer, or a label, or
		      a macro label paramerter, or
		\item a macro invocation, which has the form $\text{NAME}(i_1,...,i_r,j_1,...,j_s)$,
		      where NAME is defined in the macro definition list, $i_1,...,i_r$ and $j_1,...j_s$
		      are as for $i$ and $j$ above, and $r$ and $s$ match the number of parameters
		      in the definition.
	\end{itemize}
	In either case, a macro parameter can only occur in the body of a macro definition
	and must be one of the parameters of the definition.

	A macro definition has the form $\text{NAME}(\rho_1,...,\rho_r,\lambda_1,...,\lambda_s)=H_0\cdots H_t$
	where the $\rho_i$ are the $r$ register parameters, the $\lambda_i$ are the $s$
	label parameters and the $H_k$ are extended instructions forming the body of the
	definition.
\end{definition*}

\subsection{Pairing and encoding functions}

\begin{definition*}[Pairing function]
	A \emph{pairing function} is an injective function $\angles{-,-}_2:\N\times\N\to\N$.
	If $z=\angles{x,y}_2$ then we may write $z_0:=x$ and $z_1:=y$.
\end{definition*}

\begin{theorem*}
	Let $M$ be a general RM. Then there exists a 2-register RM $M'$ such that
	$M'$ computes a suitable encoding of $M$.
\end{theorem*}

\begin{definition*}[RM encoding]
	Let $M$ be a register machine and let $R$ be the register contents $R_0,...,R_{m-1}$,
	$P=I_0,...,I_{n-1}$ be the program itself and let $C$ be the program counter.
	Let $\angles{-,-}$ be a sequence encoding function.

	We define the RM coding function $\ucorners{-}$ by:
	\begin{align*}
		\ucorners{\inc(i)}     & = \angles{0,i}                   \\
		\ucorners{\decjz(i,j)} & = \angles{1,\angles{i,j}}        \\
		\ucorners{P}           & = \angles{\ucorners{I_0}, ..., \ucorners{I_{n-1}}} \\
		\ucorners{R}           & = \angles{R_0, ..., R_{m-1}}     \\
		\ucorners{M}           & = \angles{\ucorners{P}, \ucorners{R}, C}
	\end{align*}
\end{definition*}

\begin{theorem*}[Universal machine; Notes I.7]
	There is a register machine $U$ which takes as input the code $\left[M\right]$ of the
	initial state of an arbitrary RM $M$ and gives as output the code of the final
	state, if there is one. If $M$ does not halt, $U$ does not halt on input
	$\left[M\right]$.
\end{theorem*}

\subsection{Turing machines}

\begin{definition*}[TM; Sipser]
	A \emph{Turing machine} is a 7-tuple, $(Q, \Sigma, \Gamma, \delta, q_0, q_a, q_r)$,
	where $Q,\Sigma,\Gamma$ are all finite sets and
	\begin{enumerate}
		\item $Q$ is the set of states,
		\item $\Sigma$ is the input alphabet not containing the \emph{blank symbol $\sqcup$},
		\item $\Gamma$ is the tape alphabet, where $\sqcup\in\Gamma$ and $\Sigma\subset\Gamma$,
		\item $\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R\}$ is the transition function,
		\item $q_0\in Q$ is the start state,
		\item $q_a\in Q$ is the accept state,
		\item $q_r\in Q$ is the reject state.
	\end{enumerate}
\end{definition*}

\begin{definition*}[Turing recognisable; Sipser p. 170]
	A language is \emph{Turing-recognisable} or \emph{recursively enumerable}
	iff some Turing machine recognises it.
\end{definition*}

\begin{definition*}[Decider; Sipser p. 170]
	A \emph{decider} is a Turing machine that always halts. A language is called
	\emph{Turing-decidable} or \emph{recursive} if some Turing machine decides it.
\end{definition*}

\subsection{Variants of Turing machines}

\begin{theorem*}[Sipser p. 176-180]
	Let $L$ be a language. Then the following are equivalent:
	\begin{enumerate}
		\item $L$ is Turing-recognisable.
		\item Some multitape Turing machine recognises it.
		\item Some nondeterministic Turing machine recognises it.
	\end{enumerate}
\end{theorem*}

\begin{corollary*}[Sipser p. 180]
	A language is decidable if and only if some nondeterministic Turing machine
	decides it.
\end{corollary*}

\section{Computability}

\subsection{Halting problem}

\begin{definition*}[Computable functions]
	A (total) function $f:\N\to\N$ is \emph{computable} if there is an RM/TM which
	computes $f$ and always terminates.
\end{definition*}

\begin{theorem*}
	There exists a function $f:\N\to\N$ which is not computable.
	\begin{proof}
		Note we can encode RMs as natural numbers, thus the set of all RMs is countable.
		By diagonalisation, we may show that the set of all functions $f:\N\to\N$ is
		uncountable. Thus there are more functions than RMs.
	\end{proof}
\end{theorem*}

\begin{theorem*}[Halting theorem]
	There is no Register Machine $H$ such that $H$ takes as input an RM state encoding
	$\ucorners{M}$ and halts with output $1$ if $M$ halts or output $0$ if $M$ does not halt.
\end{theorem*}


\begin{definition*}[Decision problem]
	A \emph{decision problem} is a set $D$ and a subset $Q\subseteq D$.
	The problem is \emph{computable} iff the predicate $Q$ is computable.
\end{definition*}

\subsection{Reductions}

\begin{definition*}[Oracle]
	Given a decision problem $(D,Q)$, an \emph{oracle} for $Q$ is an additional
	RM instruction $\text{ORACLE}_Q(i)$ which assumes that $R_i$ contains an
	encoding of some $d\in D$, and sets $R_i$ to contain $Q(d)$.
\end{definition*}

\begin{definition*}[Turing transucer]
	A \emph{Turing transducer} is an RM that takes an instance $d$ of a problem $(D,Q)$
	in $R_0$ and halts with instance $d'=f(d)$ of $(D',Q')$ in $R_0$.
\end{definition*}

\begin{definition*}[m-reduction]
	A \emph{mapping reduction} or \emph{many-one reduction} from $Q$ to $Q'$ is a
	Turing transducer $f$ such that $d\in Q$ iff $f(d)\in Q'$. We write $Q\leq_m Q'$
	iff there is an $m$-reduction from $Q$ to $Q'$.
\end{definition*}

\begin{definition*}[Turing reduction]
	A \emph{Turing reduction} from $(D,Q)$ to $(D',Q')$ is an RM $M$, equipped with
	an oracle for $Q'$ such that $M$ computes $Q$.
\end{definition*}

\begin{theorem*}[Notes I.15]
	Let $(D,Q)$ be a problem. Suppose there is an $m$-reduction $R(H,Q)$ from
	$(RM, H)$ to $(D,Q)$. Then $Q$ is undecidable.
\end{theorem*}

\subsection{Semi- and co-semi-decidability}

\begin{definition*}[Looping]
	The \emph{looping Problem} $L$ is the subset of Register Machines with specified
	inputs which do not terminate.
\end{definition*}

\begin{theorem*}
	$L$ is undecidable.
\end{theorem*}

\begin{definition*}[Semi-decidability]
	A problem $(D,Q)$ is \emph{semi-decidable} iff there exists a RM $M$ taking
	input $d\in D$ such that if $d\in Q$ then $M$ halts with output $1$ and if
	$d\not\in Q$ then $M$ either halts with output $0$ or not at all.
\end{definition*}

\begin{corollary*}
	The halting problem $H$ is semi-decidable.
\end{corollary*}

\begin{definition*}[Co-semi-decidability]
	A problem $(D,Q)$ is \emph{co-semi-decidable} iff there exists an RM $M$
	taking input $d\in D$ such that if $d\not\in Q$ then $M$ halts with output
	$0$ and if $d\in Q$ then $M$ either halts with output $1$ or doe snot halt.
\end{definition*}

\begin{theorem*}
	$(D,Q)$ is semi-decidable iff $(D, Q^C)$ is co-semi-decidable.
\end{theorem*}

\subsection{Enumerability and the interleaving technique}

\begin{definition*}[Enumerability]
	An enumeration of a set $S$ is a surjective function $f:\N\to S$. A set $S$
	is said to be \emph{enumerable} if there exists an enumeration of $S$.
\end{definition*}

\begin{definition*}[Computable enumerability]
	Let $Q\subseteq\N$. The set $Q$ is \emph{computably enumerable} iff there is
	an enumeration $f:\N\to Q$ of $Q$ such that $f$ is computable.
\end{definition*}

\begin{theorem*}
	Let $Q\subseteq\N$. Then the following are equivalent
	\begin{enumerate}
		\item $Q$ is computably enumerable.
		\item There is an RM $M$ which on input $i$ always halts and outputs some $q_i\in Q$,
		      and moreover $Q=\{q_i : i\geq 0\}$.
		\item There is an RM $M$ which on input $i$ outputs a coded sequence $\angles{q_0,...,q_i}$,
		      and $Q=\{q_i:i\geq 0\}$.
	\end{enumerate}
\end{theorem*}

\begin{theorem*}[Notes I.25]
	If $Q$ is decidable then $Q$ is computably enumerable.
\end{theorem*}

\begin{theorem*}[Notes I.26, I.27]
	$Q$ is semi-decidable iff $Q$ is computably enumerable.
\end{theorem*}

\subsection{Uniform halting problem}

\begin{definition*}[UH]
	The \emph{Uniform Halting Problem} is the subset of Register Machines
	which halts on every input.
\end{definition*}

\begin{theorem*}[Notes I.28]
	If $(D,Q)$ is both semi-decidable and co-semi-decidable then it is decidable.
\end{theorem*}

\begin{corollary*}
	$H$ is not co-semi-decidable and $L$ is not semi-decidable.
\end{corollary*}

\begin{corollary*}
	If there is an $m$-reduction from $H$ to $Q$ then $Q$ is not co-semi-decidable.
\end{corollary*}

\begin{theorem*}[Notes I.31]
	UH is not semi-decidable.
\end{theorem*}

\subsection{$Q$-decidability}

\begin{definition*}[Q-semi-decidability]
	Let $Q$ be a problem. We say that $Q'$ is $Q$-semi-decidable if it is semi-decidable
	by a machine equipped with an oracle for $Q$. Let $\Sigma^T(Q)$ be the class of
	$Q$-semi-decidable problems. Similarly, let $\Pi^T(Q)$ and $\Delta^T(Q)$ be the
	classes of $Q$-co-semidecidable and $Q$-decidable problems.
\end{definition*}

\begin{theorem*}
	$UH\in\Pi^T(H)$.
\end{theorem*}

\begin{definition*}[Decision hierarchy]
	Let $\Sigma_0^T=\Pi^T_0=\Delta^T_0$ be the class of decidable problems. We say
	that $Q$ is $\Sigma_{n+1}^T$ (resp. $\Pi_{n+1}^T$, $\Delta_{n+1}^T$)
	if there is some problem $Q'\in\Sigma_n^T$ such that $Q\in\Sigma^T(Q')$
	(resp. $\Pi^T(Q')$, $\Delta^T(Q')$).
\end{definition*}

\begin{theorem*}[Notes I.35]
	Let $Q$ be a problem. There is no register machine $H_Q$ with an oracle $Q$
	such that $H_Q$ takes as input an RM-with-oracle-for-$Q$ state encoding
	$\ucorners{M}$ and halts with output $1$ if $M$ halts or output $0$ if $M$ does not halt.
\end{theorem*}

\begin{theorem*}[Notes I.36]
	If $Q\in\Sigma_n^T\cap\Pi_n^T$ then $Q\in\Delta^T_n$.
\end{theorem*}

\subsection{Computability and logic}

\begin{definition*}[Characteristic formula]
	A set $S\subseteq\N$ is defined by a formula $\phi(x)$ with one free variable
	$x$ iff $S=\{x:\phi(x)\}$ and similarly for sets of tupes of numbers.
\end{definition*}

\begin{definition*}[Lightface Borel-hierarchy]
	A formula is $\Sigma_0^0$ and $\Pi_0^0$ iff it has no quantifiers, i.e. is
	constructred from basic formulae and terms using only boolean connectives.

	A formula is $\Sigma_{n+1}^0$ (resp. $\Pi_{n+1}^0$) iff it has the form
	$\exists x_1,...,x_k.\phi$ (resp. $\forall x_1,...,x_k.\phi$) where
	$\phi$ is a $\Pi_n^0$ (resp. $\Sigma_n^0$) formula.

	A set $S\subseteq\N$ is in the class $\Sigma_n^0$ (resp. $\Pi_n^0$)
	iff it can be defined by a $\Sigma_n^0$ (resp. $\Pi_n^0$)
	formula. The class $\Delta_n^0 = \Sigma_n^0\cap\Pi_n^0$.
\end{definition*}

\begin{theorem*}[Notes I.40]
	$\Sigma_n^T=\Sigma_n^0$ (and so $\Pi_n^T=\Pi_n^0$).
\end{theorem*}

\begin{theorem*}[Notes I.41]
	The language of first-order arithmetic is first-order logic with symbols for
	equality, addition and multiplication over $\N$. Any semi-decidable predicate on
	$\N$ can be defined by a $\Sigma_0^1$ formula of this logic.
\end{theorem*}

\subsection{Primitive and partial recursion}

\begin{definition*}[Primitive recursive functions]
	A function $f:\N^n\to\N$ is \emph{primitive recursive} if
	\begin{enumerate}[label=R\arabic*.]
		\item $f=0$, or
		\item $f$ is the successor function, i.e. $f(n)=S(n)=n+1$, or
		\item $f$ is a projection function, i.e. for some $i$, $f((x_1,...,x_n))=x_i$, or
		\item $f$ is a composition of a $k$-ary function $h$ with $k$ $n$-ary functions $g_1,...,g_k$, i.e.
		      $f(x_1,...,x_m)=h(g_1(x_1,...,x_m),...,g_k(x_1,...,x_m))$ where $h,g_1,...,g_k$ are p.r., or
		\item $f$ is given by the \emph{schema of primitive recursion} for some $n-1$-ary function $h$ and
		      $n+1$-ary function $h$, i.e.
		      \begin{align*}
			      f(0,x_1,...,x_k)    & = h(x_1,...,x_k)                    \\
			      f(S(y),x_1,...,x_k) & = g(y,f(y,x_1,...,x_k),x_1,...,x_k)
		      \end{align*}
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Notes I.43]
	The \emph{Ackermann function} $A:\N^2\to\N$ defined by
	\begin{align*}
		A(0,n)        & = S(n)             \\
		A(S(m), 0)    & = A(m,S(0))        \\
		A(S(m), S(n)) & = A(m, A(S(m), n))
	\end{align*}
	is not a primitive recursive function.
\end{theorem*}

\begin{definition*}[Partial recursive functions]
	A function $f:\N^n\to\N$ is \emph{partial recursive} if it is primitive recursive or
	\begin{enumerate}[label=R\arabic*.]
		\setcounter{enumi}{5}
		\item for some $(k+1)$-ary total partial recursive function $g$ it is the function $\mu(g)$
		      which returns the least $y$ such that $f(y,x_1,...,x_k)=0$ or is undefined if no such $y$
		      exists.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Notes I.45]
	The computable functions are exactly the total recursive functions. The computable partial functions
	are exactly the partial recursive functions.
\end{theorem*}

\section{P and NP}

\subsection{The class P}

\begin{definition*}[RM for complexity]
	The RM architecture is extended with the following instructions:
	\begin{itemize}
		\item $\texttt{ADD}(i,j)$ which sets $R_i=R_i+R_j$,
		\item $\text{SUB}(i,j)$ which sets $R_i=\max\{R_i-R_j,0\}$.
	\end{itemize}
	Every instruction is deemed to run in $\Theta(\lg n)$ time where $n$
	is the value of the largest register referred to by the instruction.
\end{definition*}


\begin{definition*}[Polynomial time]
	A decision problem $(\N,Q)$ or a function $f:\N\to\N$ is in $P$ or \ptime if
	it can be computed by some RM in time $t(n)\in O(n^k)$ for some $k$, where $n$ is the size
	of the input instance $d$ or function input $d$, measued as the number of bits, i.e. $\lg(d)$.

	More generally, a decision problem $(D,Q)$ or function $f:D\to D'$ is in $P$ relative to some
	measure $\abs d$ of input size if it can be computed in time $O(\abs d^k)$.
\end{definition*}

\begin{definition*}[Polynomial reduction]
	A \ptime \emph{reduction} or \emph{polynomial reduction} from $(D,Q)$ to $(D',Q')$ is
	a \ptime-computable function $r:D\to D'$ such that $d\in Q$ iff $r(d)\in Q'$.
	We write $Q\leq^P Q'$ if there exists a polynomial reduction from $Q$ to $Q'$.
\end{definition*}

\begin{definition*}
	A \emph{polynomially bounded Register Machine} is an RM together with a polynomial $f(n)$,
	such that if the size of the input is $n_0$, then the machine halts and rejects after
	executing at most $f(n_0)$ instructions. Without loss of generality, $f(n)$ may be taken to be
	$n^k$ for some $k\in\N$.

	Thus a problem $Q$ is in $P$ iff it can be computed by some polynomially bounded RM.
\end{definition*}

\begin{definition*}[Polynomial reducability]
	$(D,Q)\leq^P_T (D',Q')$ if there exists a polynomially bounded RM, equipped with an oracle
	for $Q'$, which decides $Q$.
\end{definition*}

\subsection{The class NP}

\begin{definition*}[Hamiltonian path]
	Let $G=(V,E)$ be a finite graph. A \emph{Hamiltonian path} is a sequence of vertices
	$v_1,...,v_n$ where $n=\abs V$, such that $(v,v_{i+1})\in E$ for $i<n$, and $v_i=v_j
		\Rightarrow i=j$, for all $1\leq i,j\leq n$.

	The \emph{Hamlitonian Path Problem} (HP) is the set of finite graphs which have a Hamiltonian
	path. The size of the input is $\abs G = \abs V + \abs E$.
\end{definition*}

\begin{definition*}[Timetabling]
	The \texttt{TIMETABLING} problem is the set of all tuples $(S,E,T,C)$ where $S,E,T$ are finite
	sets and $C\subseteq S\times E$ is a relation for which there exists a function $t:E\to T$
	such that, for every $s\in S$ and for every distinct pair $e,e'\in E$ such that $(s,e)\in C$
	and $(s,e')\in C$, it is the case that $t(e)\not=t(e')$.
	The size of the inputs is $\abs S + \abs E + \abs T + \abs C$.
\end{definition*}


\begin{definition*}[NRM]
	\emph{Non-deterministic Register Machines} extend the instruction set with an instruction
	$\texttt{MAYBE(j)}$. If $I_i$ is the instruction $\texttt{MAYBE}(j)$, then the next executed instruction
	may be either $I_{i+1}$ or $I_j$.

	A \emph{run} of an NRM is any sequence of instructions satisfying the execution rules. An NRM accepts
	an input $R_0$ if there exists a run that terminates with a one in $R_0$.
\end{definition*}

\begin{theorem*}[Notes II.10]
	Let $(D,Q)$ be a problem such that there is an NRM $M$ which accepts $d$ iff $d\in Q$.
	Then there is an RM $M'$ which semi-decides $Q$.

	Moreover, if $M$ halts on every run then $M'$ decides $Q$.
\end{theorem*}

\begin{definition*}
	A \emph{polynomially bounded non-deterministic Register Machine} is an NRM together with a polynomial
	$f$ such that, if the size of the input is $n_0$, then every run of the machine halts and
	rejects after executing at most $f(n_0)$ instructions.

	A problem $Q$ is in \nptime iff it can be computed by some polynomially-bounded NRM.
\end{definition*}

\begin{theorem*}[Notes II.12]
	$HP\in NP$ and $\texttt{TIMETABLING}\in NP$.
\end{theorem*}

\subsection{The class NPC}

\begin{definition*}[NP-hard, NP-complete]
	$Q$ is NP-hard iff $Q'\leq^P Q$ for every $Q\in NP$.

	$Q$ is NP-complete iff $Q\in NP$ and $Q$ is NP-hard.
\end{definition*}

\begin{theorem*}[II.15]
	If $Q$ is NP-complete and $Q'\in NP$ such that $Q\leq^P Q'$
	then $Q'$ is NP-complete.
\end{theorem*}

\begin{definition*}[SAT]
	Let $\phi$ be a boolean formula over a set $X=\{X_1, ..., X_m\}$ of 
	boolean variables. A satisfying assignment of $\phi$ is a function
	$X\to\{\bot,\top\}$ that makes $\phi$ true. $\phi$ is satisfiable iff
	there exists a satisfying assignment.

	\texttt{SAT} is the problem $\{\phi : \phi \text{ is satisfiable}\}$.
	The input size is the length of $\phi$.	
\end{definition*}

\begin{theorem*}[Cook-Levin]
	\texttt{SAT} is NP-complete.	
\end{theorem*}

\begin{definition*}[3SAT]
	\texttt{3SAT} is the problem of whethre a satisfying assignment exists for a 
	formula in 3-CNF.	
\end{definition*}

\begin{theorem*}[II.20]
	\texttt{3SAT} is NP-complete.	
\end{theorem*}

\begin{definition*}[CLIQUE]
	Let $G=(V,E)$ a graph and $k\in\N$. A $k$-clique $C\subset V$ is a 
	set such that $\abs{C} = k$ and for all $u,v\in C$, $(u,v)\in E$,
	i.e. $C$ is a complete subgraph of $G$.

	The \texttt{$k$-CLIQUE} problem is to decide whether $G$ has a $k$-clique.
\end{definition*}

\begin{theorem*}[II.22]
	\texttt{$k$-CLIQUE} is $NP$-complete.	
\end{theorem*}

\subsection{The polynomial hierarchy}

\begin{definition*}[ExpTime]
	\texttt{ExpTime} is the class of problems solvable by any exponentially
	bounded RM. \texttt{NExpTime} is the class solvable by an exponentially
	bounded NRM.	
\end{definition*}

\begin{definition*}[Polynomial hierarchy]
	Let $C$ a complexity class. A decision problem $(D,Q)$ is in the class
	co-C iff $(D, D\setminus Q)$ is in $C$. The class $P^C$ ($NP^C$) is the 
	class of problems solvable by a polynomially bounded (non-deterministic)
	RM equipped with an oracle for some problem in $C$.

	We define 
	\begin{itemize}
		\item $\Delta_0^P=\Sigma_0^P=\Pi_0^P=P$.
		\item $\Delta_{n+1}^P=P^{\Sigma_n^P}$.
		\item $\Sigma_{n+1}^P=NP^{\Sigma_n^P}$.
		\item $\Pi_{n+1}^P=\text{co-}\left(NP^{\Sigma_n^P}\right)$.
	\end{itemize}
\end{definition*}

\begin{theorem*}[II.26]
	If for some $k\in\N$ we have $\Sigma_k^P = \Pi_k^P$ then the hierarchy 
	collapses at that level and $\Sigma_n^P = \Pi_n^P$ for all $n>k$.
\end{theorem*}

\end{document}