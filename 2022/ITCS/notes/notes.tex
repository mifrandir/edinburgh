\documentclass{article}
\usepackage{notes-preamble}
\usepackage{enumitem}
\mkthmstwounified

\title{Introduction to Theoretical Computer Science (SEM6)}
\author{Franz Miltz}
\begin{document}
\maketitle
\noindent Textbook: M. Sipser, \emph{Introduction to the Theory of Computation}
\tableofcontents
\pagebreak

\section{Regular Languages}

\subsection{Finite automata}

\begin{definition*}[DFA; Sipser]
	A \emph{deterministic finite automaton} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
	\begin{enumerate}
		\item $Q$ is a finite set called the \emph{states},
		\item $\Sigma$ is a finite set called the \emph{alphabet},
		\item $\delta:Q\times\Sigma\to Q$ is the \emph{transition function},
		\item $q_0\in Q$ is the \emph{start state}, and
		\item $F\subseteq Q$ is the \emph{set of accept states}.
	\end{enumerate}
\end{definition*}

\begin{definition*}[Formal language; Sipser]
	A \emph{language} $A$ over an alphabet $\Sigma$ is a set such that for all
	$w\in A$ there exist $w_1,w_2,...,w_n\in\Sigma$ such that $w=w_1w_2\cdots w_n$.

	A finite automaton $M=(Q,\Sigma,\delta,q_0,F)$ accepts a word $w=w_1\cdots w_n\in A$
	if there exists a sequence of states $r_0,...,r_n\in Q$ such that
	\begin{enumerate}
		\item $r_0=q_0$,
		\item $\delta(r_i,w_{i+1})=r_{i+1}$, for $i<n$, and
		\item $r_n\in F$.
	\end{enumerate}
	We say $M$ recognises $A$ if and only if $A=\{w : M\text{ accepts }w\}$.
\end{definition*}

\begin{definition*}[Regular language; Sipser]
	A language is called a \emph{regular} if some finite automaton recognises it.
\end{definition*}

\begin{definition*}[Regular operations; Sipser]
	Let $A$ and $B$ be languages. We define the following \emph{regular operations}:
	\begin{enumerate}
		\item \emph{union}: $A\cup B=\{x : x \in A \text{ or } x \in B\}$.
		\item \emph{concatenation}: $A\circ B=\{xy : x \in A \text{ or } y \in B\}$.
		\item \emph{star}: $A^* = \{x_1x_2\dots x_k:k\geq 0 \text{ and each }x_i\in A\}$.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 45, 60, 62]
	The class of regular languages is closed under regular operations.
\end{theorem*}

\begin{theorem*}[Pumping lemma]
	If $A$ is a regular language, then there is a number $p$ where if $s$
	is any string in $A$ of length at least $p$, then $s$ may be divided
	into three pieces, $s=xyz$, satisfying the following conditions:
	\begin{enumerate}
		\item for each $i\geq 0$, $xy^iz\in A$,
		\item $\abs y > 0$, and
		\item $\abs{xy} \leq p$.
	\end{enumerate}
\end{theorem*}

\subsection{Nondeterminism}

\begin{definition*}[NFA; Sipser]
	A \emph{nondeterministic finite automaton} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
	\begin{enumerate}
		\item $Q$ is a finite set called the \emph{states},
		\item $\Sigma$ is a finite set called the \emph{alphabet},
		\item $\delta:Q\times\Sigma\to\mathcal{P}(Q)$ is the \emph{transition function},
		\item $q_0\in Q$ is the \emph{start state}, and
		\item $F\subseteq Q$ is the \emph{set of accept states}.
	\end{enumerate}
\end{definition*}

\begin{definition*}[$\e$-NFA; Sipser]
	An \emph{$\e$-NFA} is a $5$-tuple $(Q,\Sigma,\delta,q_0,F)$ where
	\begin{enumerate}
		\item $Q$ is a finite set called the \emph{states},
		\item $\Sigma$ is a finite set called the \emph{alphabet},
		\item $\delta:Q\times\Sigma_\e\to \mathcal{P}(Q)$ is the \emph{transition function},
		\item $q_0\in Q$ is the \emph{start state}, and
		\item $F\subseteq Q$ is the \emph{set of accept states}.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 55]
	Let $L$ be a language. Then the following statements are equivalent:
	\begin{enumerate}
		\item $L$ is regular.
		\item There exists a DFA $M$ that recognises $L$.
		\item There exists an NFA $M$ that recognises $L$.
		\item There exists an $\e$-NFA $M$ that recognises $L$.
	\end{enumerate}
\end{theorem*}

\subsection{Regular expressions}

\begin{definition*}[Regular expression]
	$R$ is a \emph{regular expression} over an alphabet $\Sigma$ if one of the following holds:
	\begin{enumerate}
		\item $R\in\Sigma$,
		\item $R=\e$,
		\item $R=\emptyset$,
		\item $R=(R_1\cup R_2)$, where $R_1,R_2$ are regular expressions,
		\item $R=(R_1\circ R_2)$, where $R_1,R_2$ are regular expressions, or
		\item $R=(R_1^*)$, where $R_1$ is a regular expression.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 66]
	A language is regular iff some regular expression describes it.
\end{theorem*}

\section{Context-free languages}

\subsection{Context-free grammars}

\begin{definition*}[CFG; Sipser]
	A \emph{context-free grammar} is a 4-tuple $(V,\Sigma,R,S)$ where
	\begin{enumerate}
		\item $V$ is a finite set called the \emph{variables},
		\item $\Sigma$ is a finite set called the \emph{terminals},
		\item $R\subseteq V\times(V\cup\Sigma)^*$ is a finite set of \emph{rules},
		\item $S\in V$ is the \emph{start variable}.
	\end{enumerate}
\end{definition*}

\begin{definition*}[Context-free language; Sipser]
	Let $G=(V,\Sigma,R,S)$ be a CFG and let $u,v\in(V\cup\Sigma)^*$.
	We say \emph{$u$ derives $v$}, written $u\Rightarrow^* v$, if $u=v$ or if a sequence
	$u_1,...,u_k$ exists for $k\geq 0$ such that
	\begin{align*}
		u\Rightarrow u_1 \Rightarrow ... \Rightarrow u_k \Rightarrow v.
	\end{align*}
	The \emph{language of the grammar} $G$ is $L=\{w\in\Sigma^*:S\Rightarrow^* w\}$,
	called a \emph{context-free language} (CFL).
\end{definition*}

\begin{definition*}[Ambiguitiy; Sipser]
	A string $w$ is derived \emph{ambiguously} in CFG $G$ if it has
	two or more different leftmost derivations. Grammar $G$ is \emph{ambiguous} if it
	generates some string ambiguously.
	A language which is only generated by ambiguous grammars is called \emph{inherently
		ambiguous}.
\end{definition*}

\begin{definition*}[Chomsky normal form; Sipser]
	A CFG $G=(V,\Sigma,R,S)$ is in \emph{Chomsky normal form} if every rule is of the
	form
	\begin{align*}
		A\to BC, \hs
		A\to a, \hs
		S\to\e
	\end{align*}
	where $a\in\Sigma$ and $B,C\in V$
\end{definition*}

\begin{theorem*}[Sipser p. 109]
	Any CFL is generated by a CFG in Chomsky normal form.
\end{theorem*}

\subsection{Pushdown automata}

\begin{definition*}[PDA; Sipser]
	A \emph{pushdown automaton} (PDA) is a 6-tuple $(Q,\Sigma,\Gamma,\delta,q_0,F)$,
	where
	\begin{enumerate}
		\item $Q$ is the finite set of states,
		\item $\Sigma$ is the finite input alphabet,
		\item $\Gamma$ is a finite set called the \emph{stack alphabet},
		\item $\delta:Q\times \Sigma_\e\times\Gamma_\e\to\mathcal{P}(Q\times\Gamma_\e)$ is the transition function,
		\item $q_0\in Q$ is the start state, and
		\item $F\subseteq Q$ is the set of accept states.
	\end{enumerate}
	Let $M=(Q,\Sigma,\Gamma,\delta,q_0,F)$ and $w=w_1\cdots w_m$, where
	$w_1,...,w_m\in\Sigma_\e$. Then $M$ accepts $w$ if there exists a sequence of
	states $r_0,...,r_m\in Q$ and strings $s_0,...,s_m\in\Gamma^*$ such that
	\begin{enumerate}
		\item $r_0=q_0$ and $s_0=\e$,
		\item for $i<m$, we have $(r_{i+1},b)\in\delta(r_i,w_{i+1},a)$, where $s_i=at$
		      and $s_{i+1}=bt$ for some $a,b\in\Gamma_\e$ and $t\in\Gamma^*$,
		\item $r_m\in F$.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Sipser p. 117]
	A language is context-free iff a PDA recognises it.
\end{theorem*}

\begin{corollary*}[Sipser p. 124]
	Every regular language is context-free.
\end{corollary*}

\subsection{Non-context-free languages}

\begin{theorem*}[Pumping lemma for context-free languages; Sipser p. 125]
	If $A$ is a context-free language, then there is a number $p$ where,
	if $s$ is any string in $A$ of length at least $p$, then $s$ may be
	divided into five pieces $s=uvxyz$ such that
	\begin{enumerate}
		\item for each $i\geq 0$ $uv^ixy^iz\in A$,
		\item $\abs{vy}>0$, and
		\item $\abs{vxy}\leq p$.
	\end{enumerate}
\end{theorem*}

\section{Register machines and Turing machines}

\subsection{Programs}

\begin{definition*}[RM]
	A \emph{register machine} (RM) has a fixed number of registers $R_0,...,R_{m-1}$
	which each hold a natural number and a fixed program, i.e. a sequence of
	instructions $P=I_0,...,I_{n-1}$. Each instruction is one of
	\begin{enumerate}
		\item $\inc(i)$, to add $1$ to $R_i$, or
		\item $\decjz(i,j)$, if $R_i=0$ then go to $I_j$, else subtract $1$ from $R_i$.
	\end{enumerate}
	Instructions are exectued instructions in order, except when
	a jump is triggered.
\end{definition*}

\begin{definition*}[RM computation]
	A \emph{state} of a register machien $M$ as above is a tuple $(R_0,...,R_{m-1},C)$
	where $R_i\in\N$ is the value of register $i$, and $0\leq C\leq n$ is the
	\emph{program counter}.

	The next state function is a partial function from states to states, defined
	as follows: if $s=(R_0,...,R_{m-1},C)$ is a state then $\text{next}(s)$ is undefined
	if $C=n$ and otherwise is $s'=(R'_0,...,R'_{m-1},C')$ where
	\begin{itemize}
		\item if $I_C = \inc(i)$ then $C'=C+1$ and $R'_i = R_i + 1$ and $R'_k=R_k$ for $k\not=i$;
		\item if $I_C=\decjz(i,j)$ and $R_i>0$ then $C'=C+1$ and $R'_i=R_i-1$ and $R'_k = k$ for $k\not = i$;
		\item if $I_C=\decjz(i,j)$ and $R_i=0$ then $C'=j$ and $R'_k=R_k$ for all $k$.
	\end{itemize}
	We write $s\to s'$ if $s'=\text{next}(s)$.

	An \emph{input} for $M$ is a tuple $R=(R_0,...,R_{m-1})$ of values for the registers.
	A \emph{run} of $M$ on input $R$ is a sequence of states $(R_0,...,R_{m-1},0)=s_0\to s_1\to\dots$
	such that either the sequence is infinite or the sequence is finite and the final
	state $s_f$ has no next state. The \emph{output} of $M$ on input $R$ is the tuple
	$R'$ of register values in state $s_f$, or undefined if there is no final state.
\end{definition*}

\begin{definition*}[ERM]
	An \emph{extended register machine program} comprises
	\begin{itemize}
		\item A set $L$ of labels,
		\item a sequence $I_0,...,I_{n-1}$ of extended instructions,
		\item a labelling function $\text{lab}:L\to\{0,..,n\}$, and
		\item a list $D_0,...,D_l$ of macro definitions.
	\end{itemize}
	An extended instruction is
	\begin{itemize}
		\item $\inc(i)$ or $\decjz(i,j)$ where $i$ is either an integer or a macro
		      register parameter and $j$ is a non-negative integer, or a label, or
		      a macro label paramerter, or
		\item a macro invocation, which has the form $\text{NAME}(i_1,...,i_r,j_1,...,j_s)$,
		      where NAME is defined in the macro definition list, $i_1,...,i_r$ and $j_1,...j_s$
		      are as for $i$ and $j$ above, and $r$ and $s$ match the number of parameters
		      in the definition.
	\end{itemize}
	In either case, a macro parameter can only occur in the body of a macro definition
	and must be one of the parameters of the definition.

	A macro definition has the form $\text{NAME}(\rho_1,...,\rho_r,\lambda_1,...,\lambda_s)=H_0\cdots H_t$
	where the $\rho_i$ are the $r$ register parameters, the $\lambda_i$ are the $s$
	label parameters and the $H_k$ are extended instructions forming the body of the
	definition.
\end{definition*}

\subsection{Pairing and encoding functions}

\begin{definition*}[Pairing function]
	A \emph{pairing function} is an injective function $\angles{-,-}_2:\N\times\N\to\N$.
	If $z=\angles{x,y}_2$ then we may write $z_0:=x$ and $z_1:=y$.
\end{definition*}

\begin{theorem*}
	Let $M$ be a general RM. Then there exists a 2-register RM $M'$ such that
	$M'$ computes a suitable encoding of $M$.
\end{theorem*}

\begin{definition*}[RM encoding]
	Let $M$ be a register machine and let $R$ be the register contents $R_0,...,R_{m-1}$,
	$P=I_0,...,I_{n-1}$ be the program itself and let $C$ be the program counter.
	Let $\angles{-,-}$ be a sequence encoding function.

	We define the RM coding function $\ucorners{-}$ by:
	\begin{align*}
		\ucorners{\inc(i)}     & = \angles{0,i}                   \\
		\ucorners{\decjz(i,j)} & = \angles{1,\angles{i,j}}        \\
		\ucorners{P}           & = \angles{\ucorners{I_0}, ..., \ucorners{I_{n-1}}} \\
		\ucorners{R}           & = \angles{R_0, ..., R_{m-1}}     \\
		\ucorners{M}           & = \angles{\ucorners{P}, \ucorners{R}, C}
	\end{align*}
\end{definition*}

\begin{theorem*}[Universal machine; Notes I.7]
	There is a register machine $U$ which takes as input the code $\left[M\right]$ of the
	initial state of an arbitrary RM $M$ and gives as output the code of the final
	state, if there is one. If $M$ does not halt, $U$ does not halt on input
	$\left[M\right]$.
\end{theorem*}

\subsection{Turing machines}

\begin{definition*}[TM; Sipser]
	A \emph{Turing machine} is a 7-tuple, $(Q, \Sigma, \Gamma, \delta, q_0, q_a, q_r)$,
	where $Q,\Sigma,\Gamma$ are all finite sets and
	\begin{enumerate}
		\item $Q$ is the set of states,
		\item $\Sigma$ is the input alphabet not containing the \emph{blank symbol $\sqcup$},
		\item $\Gamma$ is the tape alphabet, where $\sqcup\in\Gamma$ and $\Sigma\subset\Gamma$,
		\item $\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R\}$ is the transition function,
		\item $q_0\in Q$ is the start state,
		\item $q_a\in Q$ is the accept state,
		\item $q_r\in Q$ is the reject state.
	\end{enumerate}
\end{definition*}

\begin{definition*}[Turing recognisable; Sipser p. 170]
	A language is \emph{Turing-recognisable} or \emph{recursively enumerable}
	iff some Turing machine recognises it.
\end{definition*}

\begin{definition*}[Decider; Sipser p. 170]
	A \emph{decider} is a Turing machine that always halts. A language is called
	\emph{Turing-decidable} or \emph{recursive} if some Turing machine decides it.
\end{definition*}

\subsection{Variants of Turing machines}

\begin{theorem*}[Sipser p. 176-180]
	Let $L$ be a language. Then the following are equivalent:
	\begin{enumerate}
		\item $L$ is Turing-recognisable.
		\item Some multitape Turing machine recognises it.
		\item Some nondeterministic Turing machine recognises it.
	\end{enumerate}
\end{theorem*}

\begin{corollary*}[Sipser p. 180]
	A language is decidable if and only if some nondeterministic Turing machine
	decides it.
\end{corollary*}

\section{Computability}

\subsection{Halting problem}

\begin{definition*}[Computable functions]
	A (total) function $f:\N\to\N$ is \emph{computable} if there is an RM/TM which
	computes $f$ and always terminates.
\end{definition*}

\begin{theorem*}
	There exists a function $f:\N\to\N$ which is not computable.
	\begin{proof}
		Note we can encode RMs as natural numbers, thus the set of all RMs is countable.
		By diagonalisation, we may show that the set of all functions $f:\N\to\N$ is
		uncountable. Thus there are more functions than RMs.
	\end{proof}
\end{theorem*}

\begin{theorem*}[Halting theorem]
	There is no Register Machine $H$ such that $H$ takes as input an RM state encoding
	$\ucorners{M}$ and halts with output $1$ if $M$ halts or output $0$ if $M$ does not halt.
\end{theorem*}


\begin{definition*}[Decision problem]
	A \emph{decision problem} is a set $D$ and a subset $Q\subseteq D$.
	The problem is \emph{computable} iff the predicate $Q$ is computable.
\end{definition*}

\subsection{Reductions}

\begin{definition*}[Oracle]
	Given a decision problem $(D,Q)$, an \emph{oracle} for $Q$ is an additional
	RM instruction $\text{ORACLE}_Q(i)$ which assumes that $R_i$ contains an
	encoding of some $d\in D$, and sets $R_i$ to contain $Q(d)$.
\end{definition*}

\begin{definition*}[Turing transucer]
	A \emph{Turing transducer} is an RM that takes an instance $d$ of a problem $(D,Q)$
	in $R_0$ and halts with instance $d'=f(d)$ of $(D',Q')$ in $R_0$.
\end{definition*}

\begin{definition*}[m-reduction]
	A \emph{mapping reduction} or \emph{many-one reduction} from $Q$ to $Q'$ is a
	Turing transducer $f$ such that $d\in Q$ iff $f(d)\in Q'$. We write $Q\leq_m Q'$
	iff there is an $m$-reduction from $Q$ to $Q'$.
	\begin{itemize}
		\item Note that the answer may not be modified. In particular, one cannot negate 
			the answer and thus arrange $d\in Q$ iff $f(d)\not\in Q'$.
	\end{itemize}
\end{definition*}

\begin{definition*}[Turing reduction]
	A \emph{Turing reduction} from $(D,Q)$ to $(D',Q')$ is an RM $M$, equipped with
	an oracle for $Q'$ such that $M$ computes $Q$.
\end{definition*}

\begin{theorem*}[Notes I.15]
	Let $(D,Q)$ be a problem. Suppose there is an $m$-reduction $R(H,Q)$ from
	$(RM, H)$ to $(D,Q)$. Then $Q$ is undecidable.
\end{theorem*}

\subsection{Semi- and co-semi-decidability}

\begin{definition*}[Looping]
	The \emph{looping Problem} $L$ is the subset of Register Machines with specified
	inputs which do not terminate.
\end{definition*}

\begin{theorem*}
	$L$ is undecidable.
\end{theorem*}

\begin{definition*}[Semi-decidability]
	A problem $(D,Q)$ is \emph{semi-decidable} iff there exists a RM $M$ taking
	input $d\in D$ such that if $d\in Q$ then $M$ halts with output $1$ and if
	$d\not\in Q$ then $M$ either halts with output $0$ or not at all.
\end{definition*}

\begin{corollary*}
	The halting problem $H$ is semi-decidable.
\end{corollary*}

\begin{definition*}[Co-semi-decidability]
	A problem $(D,Q)$ is \emph{co-semi-decidable} iff there exists an RM $M$
	taking input $d\in D$ such that if $d\not\in Q$ then $M$ halts with output
	$0$ and if $d\in Q$ then $M$ either halts with output $1$ or not at all.
\end{definition*}

\begin{theorem*}
	$(D,Q)$ is semi-decidable iff $(D, Q^C)$ is co-semi-decidable.
\end{theorem*}

\subsection{Enumerability and the interleaving technique}

\begin{definition*}[Enumerability]
	An enumeration of a set $S$ is a surjective function $f:\N\to S$. A set $S$
	is said to be \emph{enumerable} if there exists an enumeration of $S$.
\end{definition*}

\begin{definition*}[Computable enumerability]
	Let $Q\subseteq\N$. The set $Q$ is \emph{computably enumerable} iff there is
	an enumeration $f:\N\to Q$ of $Q$ such that $f$ is computable.
\end{definition*}

\begin{theorem*}
	Let $Q\subseteq\N$. Then the following are equivalent
	\begin{enumerate}
		\item $Q$ is computably enumerable.
		\item There is an RM $M$ which on input $i$ always halts and outputs some $q_i\in Q$,
		      and moreover $Q=\{q_i : i\geq 0\}$.
		\item There is an RM $M$ which on input $i$ outputs a coded sequence $\angles{q_0,...,q_i}$,
		      and $Q=\{q_i:i\geq 0\}$.
	\end{enumerate}
\end{theorem*}

\begin{theorem*}[Notes I.25]
	If $Q$ is decidable then $Q$ is computably enumerable.
\end{theorem*}

\begin{theorem*}[Notes I.26, I.27]
	$Q$ is semi-decidable iff $Q$ is computably enumerable.
\end{theorem*}

\subsection{Uniform halting problem}

\begin{definition*}[UH]
	The \emph{Uniform Halting Problem} is the subset of Register Machines
	which halts on every input.
\end{definition*}

\begin{theorem*}[Notes I.28]
	If $(D,Q)$ is both semi-decidable and co-semi-decidable then it is decidable.
\end{theorem*}

\begin{corollary*}
	$H$ is not co-semi-decidable and $L$ is not semi-decidable.
\end{corollary*}

\begin{corollary*}
	If there is an $m$-reduction from $H$ to $Q$ then $Q$ is not co-semi-decidable.
\end{corollary*}

\begin{theorem*}[Notes I.31]
	UH is not semi-decidable.
\end{theorem*}

\subsection{$Q$-decidability}

\begin{definition*}[Q-semi-decidability]
	Let $Q$ be a problem. We say that $Q'$ is $Q$-semi-decidable if it is semi-decidable
	by a machine equipped with an oracle for $Q$. Let $\Sigma^T(Q)$ be the class of
	$Q$-semi-decidable problems. Similarly, let $\Pi^T(Q)$ and $\Delta^T(Q)$ be the
	classes of $Q$-co-semidecidable and $Q$-decidable problems.
\end{definition*}

\begin{theorem*}
	$UH\in\Pi^T(H)$.
\end{theorem*}

\begin{definition*}[Decision hierarchy]
	Let $\Sigma_0^T=\Pi^T_0=\Delta^T_0$ be the class of decidable problems. We say
	that $Q$ is $\Sigma_{n+1}^T$ (resp. $\Pi_{n+1}^T$, $\Delta_{n+1}^T$)
	if there is some problem $Q'\in\Sigma_n^T$ such that $Q\in\Sigma^T(Q')$
	(resp. $\Pi^T(Q')$, $\Delta^T(Q')$).
\end{definition*}

\begin{theorem*}[Notes I.35]
	Let $Q$ be a problem. There is no register machine $H_Q$ with an oracle $Q$
	such that $H_Q$ takes as input an RM-with-oracle-for-$Q$ state encoding
	$\ucorners{M}$ and halts with output $1$ if $M$ halts or output $0$ if $M$ does not halt.
\end{theorem*}

\begin{theorem*}[Notes I.36]
	If $Q\in\Sigma_n^T\cap\Pi_n^T$ then $Q\in\Delta^T_n$.
\end{theorem*}

\subsection{Computability and logic}

\begin{definition*}[Characteristic formula]
	A set $S\subseteq\N$ is defined by a formula $\phi(x)$ with one free variable
	$x$ iff $S=\{x:\phi(x)\}$ and similarly for sets of tupes of numbers.
\end{definition*}

\begin{definition*}[Lightface Borel-hierarchy]
	A formula is $\Sigma_0^0$ and $\Pi_0^0$ iff it has no quantifiers, i.e. is
	constructred from basic formulae and terms using only boolean connectives.

	A formula is $\Sigma_{n+1}^0$ (resp. $\Pi_{n+1}^0$) iff it has the form
	$\exists x_1,...,x_k.\phi$ (resp. $\forall x_1,...,x_k.\phi$) where
	$\phi$ is a $\Pi_n^0$ (resp. $\Sigma_n^0$) formula.

	A set $S\subseteq\N$ is in the class $\Sigma_n^0$ (resp. $\Pi_n^0$)
	iff it can be defined by a $\Sigma_n^0$ (resp. $\Pi_n^0$)
	formula. The class $\Delta_n^0 = \Sigma_n^0\cap\Pi_n^0$.
\end{definition*}

\begin{theorem*}[Notes I.40]
	$\Sigma_n^T=\Sigma_n^0$ (and so $\Pi_n^T=\Pi_n^0$).
\end{theorem*}

\begin{theorem*}[Notes I.41]
	The language of first-order arithmetic is first-order logic with symbols for
	equality, addition and multiplication over $\N$. Any semi-decidable predicate on
	$\N$ can be defined by a $\Sigma_0^1$ formula of this logic.
\end{theorem*}

\subsection{Primitive and partial recursion}

\begin{definition*}[Primitive recursive functions]
	A function $f:\N^n\to\N$ is \emph{primitive recursive} if
	\begin{enumerate}[label=R\arabic*.]
		\item $f=0$, or
		\item $f$ is the successor function, i.e. $f(n)=S(n)=n+1$, or
		\item $f$ is a projection function, i.e. for some $i$, $f((x_1,...,x_n))=x_i$, or
		\item $f$ is a composition of a $k$-ary function $h$ with $k$ $n$-ary functions $g_1,...,g_k$, i.e.
		      $f(x_1,...,x_m)=h(g_1(x_1,...,x_m),...,g_k(x_1,...,x_m))$ where $h,g_1,...,g_k$ are p.r., or
		\item $f$ is given by the \emph{schema of primitive recursion} for some $n-1$-ary function $h$ and
		      $n+1$-ary function $h$, i.e.
		      \begin{align*}
			      f(0,x_1,...,x_k)    & = h(x_1,...,x_k)                    \\
			      f(S(y),x_1,...,x_k) & = g(y,f(y,x_1,...,x_k),x_1,...,x_k)
		      \end{align*}
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Notes I.43]
	The \emph{Ackermann function} $A:\N^2\to\N$ defined by
	\begin{align*}
		A(0,n)        & = S(n)             \\
		A(S(m), 0)    & = A(m,S(0))        \\
		A(S(m), S(n)) & = A(m, A(S(m), n))
	\end{align*}
	is not a primitive recursive function.
\end{theorem*}

\begin{definition*}[Partial recursive functions]
	A function $f:\N^n\to\N$ is \emph{partial recursive} if it is primitive recursive or
	\begin{enumerate}[label=R\arabic*.]
		\setcounter{enumi}{5}
		\item for some $(k+1)$-ary total partial recursive function $g$ it is the function $\mu(g)$
		      which returns the least $y$ such that $f(y,x_1,...,x_k)=0$ or is undefined if no such $y$
		      exists.
	\end{enumerate}
\end{definition*}

\begin{theorem*}[Notes I.45]
	The computable functions are exactly the total recursive functions. The computable partial functions
	are exactly the partial recursive functions.
\end{theorem*}

\section{P and NP}

\subsection{The class P}

\begin{definition*}[RM for complexity]
	The RM architecture is extended with the following instructions:
	\begin{itemize}
		\item $\texttt{ADD}(i,j)$ which sets $R_i=R_i+R_j$,
		\item $\text{SUB}(i,j)$ which sets $R_i=\max\{R_i-R_j,0\}$.
	\end{itemize}
	Every instruction is deemed to run in $\Theta(\lg n)$ time where $n$
	is the value of the largest register referred to by the instruction.
\end{definition*}


\begin{definition*}[Polynomial time]
	A decision problem $(\N,Q)$ or a function $f:\N\to\N$ is in $P$ or \ptime if
	it can be computed by some RM in time $t(n)\in O(n^k)$ for some $k$, where $n$ is the size
	of the input instance $d$ or function input $d$, measued as the number of bits, i.e. $\lg(d)$.

	More generally, a decision problem $(D,Q)$ or function $f:D\to D'$ is in $P$ relative to some
	measure $\abs d$ of input size if it can be computed in time $O(\abs d^k)$.
\end{definition*}

\begin{definition*}[Polynomial reduction]
	A \ptime \emph{reduction} or \emph{polynomial reduction} from $(D,Q)$ to $(D',Q')$ is
	a \ptime-computable function $r:D\to D'$ such that $d\in Q$ iff $r(d)\in Q'$.
	We write $Q\leq^P Q'$ if there exists a polynomial reduction from $Q$ to $Q'$.
\end{definition*}

\begin{definition*}
	A \emph{polynomially bounded Register Machine} is an RM together with a polynomial $f(n)$,
	such that if the size of the input is $n_0$, then the machine halts and rejects after
	executing at most $f(n_0)$ instructions. Without loss of generality, $f(n)$ may be taken to be
	$n^k$ for some $k\in\N$.

	Thus a problem $Q$ is in $P$ iff it can be computed by some polynomially bounded RM.
\end{definition*}

\begin{definition*}[Polynomial reducability]
	$(D,Q)\leq^P_T (D',Q')$ if there exists a polynomially bounded RM, equipped with an oracle
	for $Q'$, which decides $Q$.
\end{definition*}

\subsection{The class NP}

\begin{definition*}[Hamiltonian path]
	Let $G=(V,E)$ be a finite graph. A \emph{Hamiltonian path} is a sequence of vertices
	$v_1,...,v_n$ where $n=\abs V$, such that $(v,v_{i+1})\in E$ for $i<n$, and $v_i=v_j
		\Rightarrow i=j$, for all $1\leq i,j\leq n$.

	The \emph{Hamlitonian Path Problem} (HP) is the set of finite graphs which have a Hamiltonian
	path. The size of the input is $\abs G = \abs V + \abs E$.
\end{definition*}

\begin{definition*}[Timetabling]
	The \texttt{TIMETABLING} problem is the set of all tuples $(S,E,T,C)$ where $S,E,T$ are finite
	sets and $C\subseteq S\times E$ is a relation for which there exists a function $t:E\to T$
	such that, for every $s\in S$ and for every distinct pair $e,e'\in E$ such that $(s,e)\in C$
	and $(s,e')\in C$, it is the case that $t(e)\not=t(e')$.
	The size of the inputs is $\abs S + \abs E + \abs T + \abs C$.
\end{definition*}


\begin{definition*}[NRM]
	\emph{Non-deterministic Register Machines} extend the instruction set with an instruction
	$\texttt{MAYBE(j)}$. If $I_i$ is the instruction $\texttt{MAYBE}(j)$, then the next executed instruction
	may be either $I_{i+1}$ or $I_j$.

	A \emph{run} of an NRM is any sequence of instructions satisfying the execution rules. An NRM accepts
	an input $R_0$ if there exists a run that terminates with a one in $R_0$.
\end{definition*}

\begin{theorem*}[Notes II.10]
	Let $(D,Q)$ be a problem such that there is an NRM $M$ which accepts $d$ iff $d\in Q$.
	Then there is an RM $M'$ which semi-decides $Q$.

	Moreover, if $M$ halts on every run then $M'$ decides $Q$.
\end{theorem*}

\begin{definition*}[NP]
	A \emph{polynomially bounded non-deterministic Register Machine} is an NRM together with a polynomial
	$P\in\R[x]$ such that, if the size of the input is $n$, then every run of the machine halts and
	rejects after executing at most $P(n)$ instructions.

	A problem $Q$ is in \nptime iff it can be computed by some polynomially-bounded NRM.
\end{definition*}

\begin{theorem*}[Notes II.12]
	$HP\in NP$ and $\texttt{TIMETABLING}\in NP$.
\end{theorem*}

\subsection{The class NPC}

\begin{definition*}[NP-hard, NP-complete]
	$Q$ is NP-hard iff $Q'\leq^P Q$ for every $Q\in NP$.

	$Q$ is NP-complete iff $Q\in NP$ and $Q$ is NP-hard.
\end{definition*}

\begin{theorem*}[II.15]
	If $Q$ is NP-complete and $Q'\in NP$ such that $Q\leq^P Q'$
	then $Q'$ is NP-complete.
\end{theorem*}

\begin{definition*}[SAT]
	Let $\phi$ be a boolean formula over a set $X=\{X_1, ..., X_m\}$ of 
	boolean variables. A satisfying assignment of $\phi$ is a function
	$X\to\F_2$ that makes $\phi$ true. $\phi$ is satisfiable iff
	there exists a satisfying assignment.

	\texttt{SAT} is the problem $\{\phi : \phi \text{ is satisfiable}\}$.
	The input size is the length of $\phi$.	
\end{definition*}

\begin{theorem*}[Cook-Levin]
	\texttt{SAT} is NP-complete.	
\end{theorem*}

\begin{definition*}[3SAT]
	\texttt{3SAT} is the problem of whethre a satisfying assignment exists for a 
	formula in 3-CNF.	
\end{definition*}

\begin{theorem*}[II.20]
	\texttt{3SAT} is NP-complete.	
\end{theorem*}

\begin{definition*}[CLIQUE]
	Let $G=(V,E)$ a graph and $k\in\N$. A $k$-clique $C\subset V$ is a 
	set such that $\abs{C} = k$ and for all $u,v\in C$, $(u,v)\in E$,
	i.e. $C$ is a complete subgraph of $G$.

	The \texttt{$k$-CLIQUE} problem is to decide whether $G$ has a $k$-clique.
\end{definition*}

\begin{theorem*}[II.22]
	\texttt{$k$-CLIQUE} is $NP$-complete.	
\end{theorem*}

\subsection{The polynomial hierarchy}

\begin{definition*}[ExpTime]
	\texttt{ExpTime} is the class of problems solvable by any exponentially
	bounded RM. \texttt{NExpTime} is the class solvable by an exponentially
	bounded NRM.	
\end{definition*}

\begin{definition*}[Polynomial hierarchy]
	Let $C$ a complexity class. A decision problem $(D,Q)$ is in the class
	co-C iff $(D, D\setminus Q)$ is in $C$. The class $P^C$ ($NP^C$) is the 
	class of problems solvable by a polynomially bounded (non-deterministic)
	RM equipped with an oracle for some problem in $C$.

	We define 
	\begin{itemize}
		\item $\Delta_0^P=\Sigma_0^P=\Pi_0^P=P$.
		\item $\Delta_{n+1}^P=P^{\Sigma_n^P}$.
		\item $\Sigma_{n+1}^P=NP^{\Sigma_n^P}$.
		\item $\Pi_{n+1}^P=\text{co-}\left(NP^{\Sigma_n^P}\right)$.
		\item $PH=\cup_n \Sigma_n^P$.
	\end{itemize}
\end{definition*}

\begin{theorem*}[II.26]
	If for some $k\in\N$ we have $\Sigma_k^P = \Pi_k^P$ then the hierarchy 
	collapses at that level and $\Sigma_n^P = \Pi_n^P$ for all $n>k$.
\end{theorem*}

\subsection{Space complexity}

\begin{definition*}[Space-bounded RM]
	Let $f:\N\to\N$.
	A (non-)deterministic RM is $f(n)$-space bounded if it may use only $f(n)$ 
	space when computing a problem of size $n$, where space is measured in the
	number of bits required to store the register values.

	For TMs, space means the number of non-empty cells on the tape.

	\texttt{PSpace} is the class of problems solvable with polynomially-space-bounded
	machines.
\end{definition*}

\begin{theorem*}[II.28]
	The following hold:
	\begin{enumerate}
		\item $\texttt{PTime}\subseteq\texttt{PSpace}$,
		\item $\texttt{NPTime}\subseteq\texttt{PSpace}$,
		\item $\texttt{PSpace}\subseteq\texttt{ExpTime}$,
		\item $PH\subseteq\texttt{PSpace}$,
		\item if $PH=\texttt{PSpace}$ then the polynomially hierarchy collapses.
	\end{enumerate}	
\end{theorem*}

\section{Lambda calculus}

\subsection{Untyped lambda calculus}

\begin{definition}[Untyped \lambda-calculus]
	\label{untyped lcalc}
	The untyped lambda-calculus is a set of terms $\mathcal{T}$ given by the following rules:
	\begin{enumerate}[label=L\arabic*.]
		\item There is a countable set of variables $\mathcal{V}$. Every variable is a term.
		\item If $x\in\mathcal{V}$ and $t\in\mathcal{T}$ then $(\lambda x.t)\in\mathcal{T}$.
		\item \label{l3a} If $s,t\in\mathcal{T}$ then $(st)\in\mathcal{T}$.
	\end{enumerate}	
	Conventions:
	\begin{itemize}
		\item Application is left-associative. 
		\item Application takes precedence over abstraction.
		\item For $t\in\mathcal{T}$, we denote by $\mathcal{V}(t)$ the set of variables in $t$.
		\item For $t\in\mathcal{T}$, we denote by $\mathcal{T}(t)$ the set of subterms of $t$, including $t$.
	\end{itemize}
\end{definition}

\begin{definition*}[Free and bound occurences]
	If $x\in\mathcal{V}(t)$ the occurence is free in $t$ iff $x$ is not inside a subterm 
	$\lambda x.t'$ of $t$. If $x$ is free in $t'$, it is bound in $\lambda x.t'$.
\end{definition*}

\subsection{Conversions and reductions}

\begin{definition*}[\alpha-conversion]
	An \alpha-conversion of a term $t$ is an instance of the following procedure: let 
	$\lambda x.t'\in \mathcal{T}(t)$, and let $y\in\mathcal{V}$ such that $y$ is not free 
	in $t'$. Replace the binding occurence of $x$, and every free occurence of $x$ in $t'$
	by $y$.

	We write $s\to_\alpha t$ if $s$ can be converted to $t$ by a sequence of $\alpha$-conversions.
\end{definition*}

\begin{definition*}[\beta-reduction]
	Let $t=(\lambda x.t')s$ be an application $u$ of the \beta-redex $t$ is constructed as follows:
	\begin{enumerate}
		\item \alpha-convert $(\lambda x. t')$ to $(\lambda x'.t'')$ such that every bound variable in is 
			not free in $s$.
		\item Substitute $s$ for every free occurence of $x'$ in $t''$.
	\end{enumerate}
	We write $t\to_\beta u$.
\end{definition*}

\begin{definition*}[\eta-equivalence]
	If $x\in\mathcal{V}$ is not free in $f$ then $(\lambda x. f x)$ is \eta-equivalent to $f$. We write 
	$(\lambda x. f x)\leftrightarrow_\eta f$.	
\end{definition*}

\begin{definition*}[Evaluation]
	An evaluation strategy is a rule which, given a lambda-term, decides which $\beta$-redex to reduce 
	next. 

	Call by name is the following stragey. Let $t\in\mathcal{T}$. Then 
	\begin{itemize}
		\item if $t$ is $(\lambda x. u) v$ then \beta-reduce it; otherwise,
		\item if $t$ is $uv$ then reduce in $u$ if possible.
	\end{itemize}
	Call by value is the following stragey. Let $t\in\mathcal{T}$. Then 
	\begin{itemize}
		\item if $t$ is $(\lambda x. u) v$ then reduce in $v$ if possible; otherwise $\beta$-reduce it; otherwise,
		\item if $t$ is $uv$, reduce $u$ if possible.
	\end{itemize}
	Full leftmost redution is the strategy that chooses the leftmost redex and reduces it.
\end{definition*}

\begin{definition*}[Y-combinator]
	Let $Y$ denote the lambda-term 
	\begin{align*}
		Y := \lambda f. (\lambda x. f (x x)) (\lambda x. f (x x)).
	\end{align*}	
\end{definition*}

\begin{lemma*}
	\begin{align*}
		Y g \to_\beta g (Y g).
	\end{align*}
\end{lemma*}

\subsection{Simple types}

\begin{definition}[Types and simply typed syntax]
	\label{simply typed lcalc}
	The set of types $\mathcal{O}$ is defined as follows:
	\begin{itemize}
		\item Let $\mathcal{O}_0\subseteq\mathcal{O}$ a set of base types.
		\item If $\sigma,\tau\in\mathcal{O}$ then $(\sigma\to\tau)\in\mathcal{O}$.
	\end{itemize}	
	The syntax of simply typed lambda-calculus is identical to \ref{untyped lcalc} except \ref{l3a}
	is replaced by 
	\begin{enumerate}[label=L3'.]
		\item \label{l3b} If $x\in\mathcal{V}$, $t\in\mathcal{T}$, and $\tau\in\mathcal{O}$ then 
			$(\lambda x:\sigma. t) \in\mathcal{T}$.
	\end{enumerate} 
	Convention:
	\begin{itemize}
		\item $\sigma\to\tau\to\pi\equiv \sigma\to(\tau\to\pi)$.
	\end{itemize}
\end{definition}

\begin{definition*}[Judgement]
	Let $t\in\mathcal{T}$ and $\tau\in\mathcal{O}$. Then the judgement $t:\tau$ is defined by
	induction on the structure of terms. If $t$ has a type, we say it is well typed.
	\begin{itemize}
		\item Constants are well typed with their assigned type.
		\item If $t:\tau$ under the assumption that $x:\sigma$, then $(\lambda x. \sigma.t):\sigma\to\tau$.
		\item If $t:\sigma\to\tau$ and $s:\sigma$ then $(ts):\tau$.
	\end{itemize}
\end{definition*}

\begin{definition*}[Proof of judgement]
	The judgement $\Gamma\vdash t:\tau$ is true iff it can be proved from the following rules and 
	axioms:
	\begin{itemize}
		\item Constant axioms: For any set of assumptions $\Gamma$, and for every constant $c$, there is an axiom \begin{align*}
			\infer{\Gamma \vdash c:\tau}{}
		\end{align*}
		where $\tau$ is the type assigned to $c$ by its definition.
		\item Variable rule: \begin{align*}
			\infer{\Gamma\vdash x:\sigma}{x:\sigma \in\Gamma}.
		\end{align*}
		\item Abstraction rule: \begin{align*}
			\infer{\Gamma\vdash \lambda x:\sigma.t:\sigma\to\tau}{\Gamma,x:\sigma\vdash t:\tau}.
		\end{align*}
		\item Application rule: \begin{align*}
			\infer{\Gamma \vdash ts : \tau }{\Gamma \vdash t : \sigma\to\tau \hs \Gamma\vdash s:\sigma}
		\end{align*}
	\end{itemize}
\end{definition*}

\begin{theorem*}[Uniqueness of types]
	In a given consistent set of assumptions, any simply typed lambda term has at most one type. 
\end{theorem*}

\begin{theorem*}[III.11]
	The set of well-typed lambda terms is decidable in \ptime.
\end{theorem*}

\begin{theorem*}[Type safety]
	The type of a term remains unchanged under $\alpha$, $\beta$, $\eta$-conversion.
\end{theorem*}

\begin{theorem*}[Strong normalisation]
	A well typed term evaluates under \beta-reduction in finitely many steps to a unique irreducible
	term. If the type is a base type, then the irreducible term is a constant.
\end{theorem*}

\begin{corollary*}[III.14]
	Simply typed lambda calculus is not Turing-complete.
\end{corollary*}

\begin{proposition*}[III.15]
	Any term containing a self-application cannot be given a simple type.
\end{proposition*}

\subsection{Recursion}

\begin{definition*}[Recursion for simple types]
	The syntax in \ref{simply typed lcalc} is extended as follows:
	\begin{enumerate}[label=L4.]
		\item If $t\in\mathcal{T}$ then $(\textbf{fix }t)\in\mathcal{T}$.
	\end{enumerate}	
	The $\beta$-reduction rules are extended by \begin{align*}
		\textbf{fix}(\lambda x:\tau.t)\to_\beta t[\textbf{fix}(\lambda x:\tau.t)/x].
	\end{align*}
	A new typing rule is added: \begin{align*}
		\infer{\Gamma \vdash \textbf{fix }t:\tau}{\Gamma \vdash t:\tau\to\tau}.
	\end{align*}
\end{definition*}

\begin{definition*}[let]
	For $x\in\mathcal{V}$, $\tau\in\mathcal{O}$, and $t,t'\in\mathcal{T}$,
	\begin{align*}
		(\textbf{let $x:\tau = t$ in $t'$}) := (\lambda x:t.t')t.	
	\end{align*}
\end{definition*}

\begin{definition*}[letrec]
	For $x\in\mathcal{V}$, $\tau\in\mathcal{O}$, and $t,t'\in\mathcal{T}$,
	\begin{align*}
		(\textbf{letrec $x:\tau=t$ in $t'$}) := (\textbf{let $x:\tau=$ fix$(\lambda x:\tau.t)$ in $t'$}).	
	\end{align*}
\end{definition*}

\subsection{Type variables}

\begin{definition*}[Type variables]
	There is a set $\mathcal{O}_1\subseteq\mathcal{O}$ of type variables. A type $\sigma\in\mathcal{O}$
	that contains no type variables is called \emph{closed}.

	A \emph{type substitution} is a function $\mathcal{O}_1\to\mathcal{O}$. If
	$\mathcal{T}:\mathcal{O}_1\to\mathcal{O}$ and $t\in\mathcal{T}$ then $\mathcal{F} t$ is the result 
	of applying $\mathcal{F}$ to $t$; similarly, we applyl substitutions to types, assumptions, etc.
	We specify substitutions explicitly by the notation $[\mathcal{F}(\alpha)/\alpha, 
	\mathcal{F}(\beta)/\beta,...]$.
\end{definition*}

\begin{proposition*}[III.20]
	If $\Gamma\vdash t:\tau$ and $\mathcal{F}$ is a type substitution then $\mathcal{F}\Gamma \vdash \mathcal{F}t:\mathcal{F}\tau$.
\end{proposition*}

\begin{definition*}[]
	Let $\sigma,\tau\in\mathcal{T}$. A \emph{type equation} is an equation of the form $\sigma=\tau$. A solution
	to the equation is a type substitution $\mathcal{F}$ such that $\mathcal{F}\sigma=\mathcal{F}\tau$. A 
	solution to a set of equations is a substitution that solves all equations simultaneously.

	We modify the typing proof rules:
	\begin{itemize}
		\item Constant axiom schema: \begin{align*}
			\infer{\Gamma\vdash c:\tau}{}
		\end{align*}
		which generates the equation $\tau=\tau'$ where $\tau'$ is the type assigned to $c$.
		\item Variable rule: \begin{align*}
			\infer{\Gamma\vdash x:\sigma}{x:\sigma'\in\Gamma}
		\end{align*}
		which generates the equation $\sigma'=\sigma$
		\item Abstraction rule: \begin{align*}
			\infer{\Gamma\vdash\lambda x.t:\sigma}{\Gamma,x:\alpha\vdash t:\beta}
		\end{align*}
		which generates the equation $\alpha\to\beta = \sigma$ where $\alpha,\beta$ are new type variables j.
		\item Application rule: \begin{align*}
			\infer{\Gamma\vdash ts:\tau}{\Gamma\vdash t:\alpha\to\tau\hs \Gamma\vdash s:\alpha}
		\end{align*}
		where $\alpha$ is a new type variable.
	\end{itemize}
	We say $t:\tau$ iff there is a proof-tree for some $\vdash t:\tau'$ and there is a solution $\mathcal{F}$
	for the set of equations generated by the pfoorf tree, such that $\tau=\mathcal{F}\tau'$.
\end{definition*}

\begin{proposition*}[III.22]
	Given a set of type equations, we can in linear time either find a solution or show that no solutioin exists.

	Moreover, we can find the most general solution, i.e. a solution $\mathcal{F}$ such that any other 
	solution $\mathcal{F}'$ is equal to $\mathcal{F}''$ applied to $\mathcal{F}$ for some $\mathcal{F}''$.
\end{proposition*}

\subsection{Polymorphism}

\begin{definition*}[Let-polymorphic lambda calculus]
	The let-polymorphic lambda-calculus extends the untyped lambda calculus together with the 
	\textbf{fix} constructor and any other primitve terms, with the following term construction:
	\begin{enumerate}[label=L5.]
		\item If $x\in\mathcal{V}$ and $t,t'\in\mathcal{T}$ then $(\textbf{let $x=t$ in $t'$})\in\mathcal{T}$.
	\end{enumerate}
	The \beta-reduction rule for this term is \begin{align*}
		\textbf{let $x=t$ in $t'\to_\beta t'[t/x]$}.
	\end{align*}
\end{definition*} 

\begin{definition*}[let proof rules]
	If $\tau\in\mathcal{O}$ and $\alpha,\beta\in\mathcal{O}_1$ then $\forall \alpha, \beta, ... .\tau$ 
	is a \emph{type scheme}, and the variables are bound in it. The type scheme $\forall.\tau$ with
	no bound variables is identified with the type $\tau$.
	
	Assumptions are extended to be $x:\tau$ where $\tau$ is a type scheme, and in the following $\sigma,\tau$
	range over type schemes.

	Let $\Sigma$ be a set of assumptions and let $\sigma$ be a type scheme. $\bar\Gamma(\sigma)$ denotes 
	the generalisation of $\sigma$ with respect to $\Gamma$, which is defined to be the result of binding 
	with $\forall$ all type variables in $\sigma$ that do not occur free in $\Gamma$.

	If $\sigma,\tau\in\mathcal{O}$ we say $\tau$ specialises $\sigma$, written $\sigma\sqsubseteq \tau$ 
	iff $\sigma$ has the form $\forall \alpha, \beta, ... .\sigma'$ and $\tau$ is the result of subsituting 
	types for some of the $\alpha,\beta, ...$ in $\sigma'$, and removing them from the bound variable list.

	The typing rule for \textbf{let} expressions is 
	\begin{align*}
		\infer{\Gamma\vdash \textbf{let $x=t$ in $t':\tau$}}{\Gamma\vdash t:\sigma\hs \Gamma,x:\bar\Gamma(\sigma)\vdash t':\tau}
	\end{align*}
	and the typing rule for variables and assumptions is modified to be 
	\begin{align*}
		\infer{\Gamma \vdash x:\tau}{x:\sigma \in \Gamma\hs \sigma\sqsubseteq \tau}.
	\end{align*}
\end{definition*}

\begin{theorem*}[III.27]
	Type-checking let-polymorphic lambda-calculus is \texttt{ExpTime}-complete.
\end{theorem*}

\end{document}